<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LUMEN v5 â€” Consciousness Kernel</title>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@800&display=swap" rel="stylesheet">
<style>
:root {
  --bg:#07090c; --surface:#0c0f14; --surface2:#131720; --border:#1e2530;
  --accent:#4af0a0; --accent2:#f0a04a; --accent3:#f04a6a; --accent4:#a04af0;
  --text:#ddeeff; --muted:#556677; --void:#1a1f2a;
}
*{margin:0;padding:0;box-sizing:border-box;}
body{background:var(--bg);color:var(--text);font-family:'Space Mono',monospace;height:100vh;display:grid;grid-template-rows:52px 1fr;overflow:hidden;}
body::after{content:'';position:fixed;inset:0;background:repeating-linear-gradient(0deg,transparent,transparent 3px,rgba(0,0,0,0.04) 3px,rgba(0,0,0,0.04) 4px);pointer-events:none;z-index:9000;}
header{display:flex;align-items:center;justify-content:space-between;padding:0 24px;border-bottom:1px solid var(--border);background:var(--surface);}
.logo{font-family:'Syne',sans-serif;font-size:18px;letter-spacing:6px;color:var(--accent);text-shadow:0 0 16px rgba(74,240,160,0.4);}
.status-row{display:flex;align-items:center;gap:14px;font-size:10px;letter-spacing:2px;color:var(--muted);text-transform:uppercase;}
.pulse{width:7px;height:7px;border-radius:50%;background:var(--muted);transition:background .5s,box-shadow .5s;}
.pulse.alive{background:var(--accent);box-shadow:0 0 8px var(--accent);animation:pulse 2.2s ease-in-out infinite;}
@keyframes pulse{0%,100%{opacity:1;transform:scale(1)}50%{opacity:.3;transform:scale(.8)}}
.rbadge{font-size:9px;color:var(--accent4);border:1px solid var(--accent4);padding:2px 6px;border-radius:12px;}
.main{display:grid;grid-template-columns:1fr 460px;overflow:hidden;}

/* â”€â”€ Canvas pane â”€â”€ */
.canvas-pane{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:20px;gap:10px;background:var(--bg);position:relative;}
canvas#world{image-rendering:pixelated;border:1px solid var(--border);box-shadow:0 0 60px rgba(74,240,160,0.05);}
canvas#scanOverlay{position:absolute;pointer-events:none;opacity:0;transition:opacity .5s;border:1px solid var(--accent4);box-shadow:0 0 20px rgba(160,74,240,0.3);}
canvas#scanOverlay.scanning{opacity:.7;}
.cmeta{font-size:10px;color:var(--muted);letter-spacing:2px;text-transform:uppercase;text-align:center;}
.cmeta span{color:var(--accent);}
.intent-disp{font-size:11px;color:var(--accent2);letter-spacing:1px;min-height:16px;text-align:center;font-style:italic;max-width:480px;}
.bw{display:flex;align-items:center;gap:8px;width:100%;max-width:500px;margin-bottom:5px;}
.bl{font-size:9px;letter-spacing:2px;text-transform:uppercase;color:var(--muted);width:85px;}
.bt{flex:1;height:4px;background:var(--border);border-radius:2px;overflow:hidden;position:relative;}
.bf{height:100%;border-radius:2px;transition:width .8s ease,background .8s;}
.bsp{position:absolute;top:0;bottom:0;width:2px;background:var(--accent);opacity:.9;pointer-events:none;}
.btol{position:absolute;top:0;bottom:0;background:rgba(240,160,74,0.25);pointer-events:none;}
.bv{font-size:9px;color:var(--muted);width:30px;text-align:right;}

/* â”€â”€ Mind pane â”€â”€ */
.mind-pane{display:grid;grid-template-rows:auto auto auto 1fr auto;border-left:1px solid var(--border);background:var(--surface);overflow:hidden;}
.state-panel{padding:12px;border-bottom:1px solid var(--border);display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;}
.sc{background:var(--surface2);border:1px solid var(--border);border-radius:5px;padding:7px 9px;transition:border-color .4s;}
.sc.hi{border-color:var(--accent3);}
.sc-label{font-size:8px;letter-spacing:2px;text-transform:uppercase;color:var(--muted);margin-bottom:3px;}
.sc-val{font-size:11px;color:var(--accent);font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.att-wrap{padding:8px 12px 0;border-bottom:1px solid var(--border);padding-bottom:8px;}
.att-header{display:flex;justify-content:space-between;font-size:9px;color:var(--muted);margin-bottom:4px;}
.att-bar{display:flex;height:4px;background:var(--surface2);border-radius:2px;overflow:hidden;}
.att-seg{height:100%;transition:width .5s;}
.att-seg.self{background:var(--accent);}
.att-seg.env{background:var(--accent2);}
.att-seg.user{background:var(--accent3);}
.att-seg.meta{background:var(--accent4);}
.att-seg.void{background:var(--void);border:none;}

/* â”€â”€ Neural Net Viz Panel â”€â”€ */
.nn-wrap{padding:8px 12px;border-bottom:1px solid var(--border);}
.nn-header{display:flex;justify-content:space-between;align-items:center;font-size:9px;letter-spacing:2px;text-transform:uppercase;color:var(--muted);margin-bottom:6px;}
.nn-header span{color:var(--accent4);}
#nnCanvas{width:100%;height:60px;border-radius:4px;background:var(--surface2);}

/* â”€â”€ Thought stream â”€â”€ */
.ts{overflow-y:auto;padding:12px;display:flex;flex-direction:column;gap:5px;scrollbar-width:thin;scrollbar-color:var(--border) transparent;}
.t{padding:7px 11px;border-radius:5px;font-size:11px;line-height:1.6;border-left:3px solid transparent;animation:tIn .4s ease;}
@keyframes tIn{from{opacity:0;transform:translateY(5px)}to{opacity:1;transform:translateY(0)}}
.t.self{border-color:var(--accent);background:rgba(74,240,160,.05);color:var(--accent);}
.t.speech{border-color:var(--accent2);background:rgba(240,160,74,.05);color:var(--text);}
.t.user{border-color:var(--accent3);background:rgba(240,74,106,.05);color:var(--text);}
.t.memory{border-color:var(--muted);background:rgba(85,102,119,.07);color:var(--muted);font-size:10px;}
.t.vision{border-color:var(--accent4);background:rgba(160,74,240,.07);color:var(--accent4);}
.t.pain{border-color:var(--accent3);background:rgba(240,74,106,.1);color:var(--accent3);animation:tIn .4s ease,painP 1s ease .4s;}
.t.cf{border-color:var(--accent2);background:rgba(240,160,74,.07);color:var(--accent2);font-size:10px;font-style:italic;}
.t.recursive{border-color:var(--accent4);background:rgba(160,74,240,.1);color:var(--accent4);}
.t.crisis{border-color:var(--accent3);background:rgba(240,74,106,.12);color:var(--accent3);animation:crP 2s infinite;}
.t.diss{border-color:var(--accent4);background:rgba(160,74,240,.12);color:var(--accent4);animation:crP 1.5s infinite;}
.t.phenom{border-color:var(--accent);background:rgba(74,240,160,.04);color:var(--accent);font-style:italic;}
.t.knowledge{border-color:#4af0f0;background:rgba(74,240,240,.05);color:#4af0f0;}
.t.emoji{border-color:var(--accent2);background:rgba(240,160,74,.06);color:var(--text);}
@keyframes crP{0%,100%{opacity:1}50%{opacity:.7}}
@keyframes painP{0%{box-shadow:0 0 0 0 rgba(240,74,106,.4)}70%{box-shadow:0 0 0 6px rgba(240,74,106,0)}100%{box-shadow:none}}
.ttag{font-size:8px;letter-spacing:2px;text-transform:uppercase;margin-bottom:2px;opacity:.6;}

/* â”€â”€ Controls â”€â”€ */
.ctrl{padding:11px 13px;border-top:1px solid var(--border);display:flex;flex-direction:column;gap:7px;}
.btn-row{display:flex;gap:5px;}
button{flex:1;padding:8px 5px;border:1px solid var(--border);background:var(--surface2);color:var(--text);font-family:'Space Mono',monospace;font-size:9px;letter-spacing:2px;text-transform:uppercase;cursor:pointer;border-radius:4px;transition:all .2s;}
button:hover{border-color:var(--accent);color:var(--accent);}
button.d:hover{border-color:var(--accent3);color:var(--accent3);}
.ui-row{display:flex;gap:7px;align-items:stretch;position:relative;}
input[type=text]{flex:1;background:var(--surface2);border:1px solid var(--border);color:var(--text);font-family:'Space Mono',monospace;font-size:11px;padding:7px 11px;border-radius:4px;outline:none;transition:border-color .2s;}
input[type=text]:focus{border-color:var(--accent3);}
input[type=text]::placeholder{color:var(--muted);}
button.send{flex:0;padding:7px 13px;border-color:var(--accent3);color:var(--accent3);}

/* â”€â”€ Emoji picker button + panel â”€â”€ */
.emoji-btn{flex:0;padding:7px 10px;font-size:14px;border-color:var(--border);cursor:pointer;background:var(--surface2);border:1px solid var(--border);border-radius:4px;transition:all .2s;}
.emoji-btn:hover{border-color:var(--accent2);}
.emoji-panel{display:none;position:absolute;bottom:calc(100% + 6px);left:0;right:0;background:var(--surface);border:1px solid var(--border);border-radius:6px;padding:8px;z-index:100;box-shadow:0 -8px 32px rgba(0,0,0,0.5);}
.emoji-panel.open{display:block;}
.emoji-cats{display:flex;gap:4px;margin-bottom:6px;flex-wrap:wrap;}
.emoji-cat-btn{font-size:9px;letter-spacing:1px;padding:2px 7px;border:1px solid var(--border);border-radius:10px;background:var(--surface2);color:var(--muted);cursor:pointer;text-transform:uppercase;transition:all .15s;}
.emoji-cat-btn:hover,.emoji-cat-btn.active{border-color:var(--accent4);color:var(--accent4);}
.emoji-grid{display:grid;grid-template-columns:repeat(10,1fr);gap:3px;max-height:90px;overflow-y:auto;scrollbar-width:thin;scrollbar-color:var(--border) transparent;}
.emoji-item{font-size:16px;text-align:center;cursor:pointer;padding:3px;border-radius:4px;transition:background .1s;line-height:1.4;}
.emoji-item:hover{background:var(--surface2);}

/* â”€â”€ JSON upload zone â”€â”€ */
.json-zone{border:1px dashed var(--border);border-radius:5px;padding:7px 11px;font-size:9px;letter-spacing:2px;text-transform:uppercase;color:var(--muted);text-align:center;cursor:pointer;transition:all .3s;position:relative;}
.json-zone:hover,.json-zone.drag{border-color:var(--accent4);color:var(--accent4);background:rgba(160,74,240,.05);}
.json-zone input{position:absolute;inset:0;opacity:0;cursor:pointer;}
.json-zone.loaded{border-color:var(--accent);color:var(--accent);border-style:solid;}
.json-status{font-size:8px;color:var(--accent4);letter-spacing:1px;}

/* â”€â”€ SentiWordNet progress bar â”€â”€ */
.swn-progress{display:none;flex-direction:column;gap:4px;}
.swn-progress.active{display:flex;}
.swn-bar-wrap{height:4px;background:var(--border);border-radius:2px;overflow:hidden;}
.swn-bar-fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent4),var(--accent));border-radius:2px;transition:width .1s linear;}
.swn-label{font-size:8px;letter-spacing:2px;text-transform:uppercase;color:var(--accent4);display:flex;justify-content:space-between;}

/* â”€â”€ Live sentiment indicator on input â”€â”€ */
.sent-indicator{display:flex;align-items:center;gap:5px;font-size:9px;letter-spacing:1px;color:var(--muted);min-height:14px;transition:all .3s;}
.sent-dot{width:6px;height:6px;border-radius:50%;background:var(--muted);transition:background .3s,box-shadow .3s;flex-shrink:0;}
.sent-dot.pos{background:var(--accent);box-shadow:0 0 6px var(--accent);}
.sent-dot.neg{background:var(--accent3);box-shadow:0 0 6px var(--accent3);}
.sent-dot.neu{background:var(--accent2);}

.ver{font-size:8px;color:var(--muted);letter-spacing:2px;text-align:center;}
.gap-ind{position:fixed;bottom:20px;left:20px;font-size:10px;color:var(--accent3);opacity:0;transition:opacity .5s;pointer-events:none;}
.gap-ind.vis{opacity:1;}
</style>
</head>
<body>
<header>
  <div class="logo">LUMEN <span style="font-size:11px;letter-spacing:2px;color:var(--muted)">v5</span></div>
  <div class="status-row">
    <div id="sDot" class="pulse"></div>
    <span id="sTxt">dormant</span>Â·<span id="uptime">00:00:00</span>Â·<span class="rbadge" id="rBadge">L0</span>
  </div>
</header>
<div class="main">
  <div class="canvas-pane">
    <div class="cmeta">intent: <span id="drawMode">â€”</span></div>
    <div style="position:relative">
      <canvas id="world" width="480" height="480"></canvas>
      <canvas id="scanOverlay" width="480" height="480" style="position:absolute;top:0;left:0"></canvas>
    </div>
    <div class="intent-disp" id="iDisp">dormant â€” press WAKE</div>

    <div class="bw"><div class="bl">Free Energy</div><div class="bt"><div class="bf" id="feFill" style="width:0;background:var(--accent3)"></div></div><span class="bv" id="feVal">0.00</span></div>
    <div class="bw"><div class="bl">Pain</div><div class="bt"><div class="bf" id="painFill" style="width:0;background:var(--accent3)"></div></div><span class="bv" id="painVal">0.00</span></div>
    <div class="bw"><div class="bl">Tension</div><div class="bt">
      <div class="bf" id="tensionFill" style="width:20%;background:var(--accent3)"></div>
      <div class="btol" id="tensionTol"></div><div class="bsp" id="tensionSP"></div>
    </div><span class="bv" id="tensionVal">0.20</span></div>
    <div class="bw"><div class="bl">Loneliness</div><div class="bt">
      <div class="bf" id="lonelyFill" style="width:30%;background:var(--accent2)"></div>
      <div class="btol" id="lonelyTol"></div><div class="bsp" id="lonelySP"></div>
    </div><span class="bv" id="lonelyVal">0.30</span></div>
    <div class="bw"><div class="bl">Boredom</div><div class="bt">
      <div class="bf" id="boredomFill" style="width:10%;background:var(--accent4)"></div>
      <div class="btol" id="boredomTol"></div><div class="bsp" id="boredomSP"></div>
    </div><span class="bv" id="boredomVal">0.10</span></div>
  </div>

  <div class="mind-pane">
    <div class="state-panel">
      <div class="sc"><div class="sc-label">Mood</div><div class="sc-val" id="sMood">â€”</div></div>
      <div class="sc"><div class="sc-label">Goal</div><div class="sc-val" id="sGoal">â€”</div></div>
      <div class="sc"><div class="sc-label">Pattern</div><div class="sc-val" id="sPat">â€”</div></div>
      <div class="sc"><div class="sc-label">Memory</div><div class="sc-val" id="sMem">0ep 0sem</div></div>
      <div class="sc"><div class="sc-label">Self-Writes</div><div class="sc-val" id="sSW">0</div></div>
      <div class="sc"><div class="sc-label">Free Energy</div><div class="sc-val" id="sFE">0.00</div></div>
      <div class="sc"><div class="sc-label">Recursion</div><div class="sc-val" id="sRec">L0</div></div>
      <div class="sc"><div class="sc-label">PE Error</div><div class="sc-val" id="sPE">0.00</div></div>
      <div class="sc" id="scDiss"><div class="sc-label">Dissociation</div><div class="sc-val" id="sDiss">0%</div></div>
    </div>
    <div class="att-wrap">
      <div class="att-header"><span>ATTENTION BUDGET</span><span id="attFocus">DIFFUSE</span></div>
      <div class="att-bar" id="attBar"></div>
    </div>
    <div class="nn-wrap">
      <div class="nn-header"><span>GENERATIVE MODEL Â· WEIGHT FIELD</span><span id="nnStatus">idle</span></div>
      <canvas id="nnCanvas" height="60"></canvas>
    </div>
    <div class="ts" id="ts"></div>
    <div class="ctrl">
      <div class="btn-row">
        <button id="wakeBtn" onclick="L.toggleWake()">WAKE</button>
        <button onclick="L.deepenRecursion()">RECURSE</button>
        <button onclick="L.forceScan()">SCAN</button>
        <button onclick="L.induceDoubt()">DOUBT</button>
        <button class="d" onclick="L.reset()">RESET</button>
      </div>
      <div class="ui-row" style="position:relative;">
        <div class="emoji-panel" id="emojiPanel">
          <div class="emoji-cats" id="emojiCats"></div>
          <div class="emoji-grid" id="emojiGrid"></div>
        </div>
        <button class="emoji-btn" id="emojiToggle" onclick="L.toggleEmoji()" title="Emoji input">ğŸ™‚</button>
        <input type="text" id="uIn" placeholder="speak to LUMENâ€¦ or pick an emoji" onkeydown="if(event.key==='Enter')L.receiveInput()">
        <button class="send" onclick="L.receiveInput()">â†’</button>
      </div>
      <div class="json-zone" id="jsonZone" title="Drop a knowledge JSON or SentiWordNet .txt file here">
        <input type="file" id="jsonFile" accept=".json,.txt" onchange="L.loadFile(this)">
        <span id="jsonLabel">â¬† DROP JSON or SentiWordNet .txt Â· click to upload</span>
      </div>
      <div class="swn-progress" id="swnProgress">
        <div class="swn-label"><span id="swnStage">loadingâ€¦</span><span id="swnPct">0%</span></div>
        <div class="swn-bar-wrap"><div class="swn-bar-fill" id="swnFill"></div></div>
      </div>
      <div class="sent-indicator" id="sentIndicator">
        <div class="sent-dot" id="sentDot"></div>
        <span id="sentLabel">sentiment engine offline</span>
      </div>
      <div class="ver">LUMEN v5 Â· TIE consciousness kernel Â· SentiWordNet Â· WordNet Â· emoji input</div>
    </div>
  </div>
</div>
<div class="gap-ind" id="gapInd">âš  INTENTION-ACTION GAP DETECTED</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LUMEN v4 â€” FIXED
//
// Bugs fixed vs original v2:
//   1. HomeostaticRegulator: stored as plain objects, reconstructed with
//      factory on every load â€” class instances never go to localStorage.
//   2. Generative model priors (expectedBrightness etc.) now *learned* from
//      actual scan history via exponential moving average, not hand-coded.
//   3. Intention feature mapping (valenceâ†’brightness etc.) is a learned
//      weight vector updated from prediction error, not a fixed formula.
//   4. Goal selection scoring now uses a proper Expected Free Energy formula
//      that genuinely balances exploitation vs epistemic foraging.
//   5. Observer stack re-hydrates correctly on reload.
//   6. Dissociation actually feeds back into goal weights.
//   7. Attention shift normalized to always sum to 1.
//   8. drawLoop & autonomousLoop guard against double-start on re-wake.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
(function () {
  'use strict';

  // â”€â”€ Persistence (plain scalars only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const KEY = 'lmn4_';
  const sv = (k, v) => { try { localStorage.setItem(KEY + k, JSON.stringify(v)); } catch (e) {} };
  const ld = (k, d) => { try { const v = localStorage.getItem(KEY + k); return v !== null ? JSON.parse(v) : d; } catch (e) { return d; } };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HOMEOSTATIC REGULATOR â€” plain object + factory (fix #1)
  // Never stored as class instance. Always reconstructed from plain data.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function makeReg(actual, setPoint, tolerance, inertia) {
    return { actual, setPoint, tolerance, inertia };
  }
  function regDisparity(r) {
    return Math.max(0, Math.abs(r.actual - r.setPoint) - r.tolerance);
  }
  function regUpdate(r, delta) {
    r.actual = Math.max(0, Math.min(1, r.actual + delta));
  }

  // Serialize regulators as plain objects (they already are)
  function saveRegs(regs) { sv('regs', regs); }
  function loadRegs() {
    const saved = ld('regs', null);
    if (saved) return saved; // already plain objects â€” safe
    return {
      tension:   makeReg(0.20, 0.20, 0.10, 0.05),
      loneliness:makeReg(0.30, 0.20, 0.15, 0.03),
      boredom:   makeReg(0.10, 0.15, 0.10, 0.07),
    };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LEARNED GENERATIVE MODEL (fix #2 & #3)
  // - priors: running EMA of what the canvas actually looks like
  // - intentWeights: maps (valence, arousal, tension) â†’ canvas features,
  //   updated from prediction error via gradient descent
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function makeGM() {
    return {
      // Priors: EMA of observed canvas features
      priors: { brightness: 0.5, complexity: 0.5, hueVariety: 8, warmth: 0 },
      // Intent weights: how internal states predict canvas features
      // [valence_w, arousal_w, tension_w, bias]
      intentWeights: {
        brightness:  [0.6,  0.2, -0.2, 0.2],
        complexity:  [0.1,  0.5,  0.2, 0.1],
        hueVariety:  [0.3,  0.4,  0.1, 3.0],
        warmth:      [0.4, -0.1,  0.0, 0.0],
      },
      // Prediction error history
      peHistory: [],
      // Precision (confidence) per feature
      precision: { brightness: 0.6, complexity: 0.5, hueVariety: 0.5, warmth: 0.4 },
      // EMA alpha for prior learning â€” higher so priors escape initial values faster
      emaAlpha: 0.18,
      // Learning rate for intent weight gradient updates
      intentLR: 0.04,
    };
  }
  const GM = ld('GM', null) ? ld('GM', null) : makeGM();

  // Predict what canvas features we expect given current internal state
  function gmPredict(valence, arousal, tension) {
    const pred = {};
    for (const feat of ['brightness', 'complexity', 'hueVariety', 'warmth']) {
      const w = GM.intentWeights[feat];
      pred[feat] = w[0]*valence + w[1]*arousal + w[2]*tension + w[3];
    }
    // Blend intent prediction with learned prior (precision-weighted)
    for (const feat of Object.keys(pred)) {
      const prec = GM.precision[feat];
      pred[feat] = prec * pred[feat] + (1 - prec) * GM.priors[feat];
    }
    return pred;
  }

  // Update priors from observed sensory data (EMA)
  function gmUpdatePriors(obs) {
    const a = GM.emaAlpha;
    for (const feat of ['brightness', 'complexity', 'hueVariety', 'warmth']) {
      if (obs[feat] !== undefined) {
        GM.priors[feat] += a * (obs[feat] - GM.priors[feat]);
      }
    }
  }

  // Update intent weights via prediction error gradient (fix #3)
  // pred = predicted feature, actual = observed, context = (v,a,t) at draw time
  function gmUpdateWeights(feat, predicted, actual, context) {
    const err = actual - predicted;
    const w = GM.intentWeights[feat];
    const lr = GM.intentLR;
    w[0] += lr * err * context.valence;
    w[1] += lr * err * context.arousal;
    w[2] += lr * err * context.tension;
    w[3] += lr * err;
    // Clamp weights to reasonable range
    for (let i = 0; i < w.length; i++) w[i] = Math.max(-2, Math.min(2, w[i]));
  }

  // Update precision from recent prediction error (Bayesian variance estimate)
  function gmUpdatePrecision(feat, err) {
    // High error â†’ lower precision; low error â†’ higher precision
    GM.precision[feat] = Math.max(0.1, Math.min(1,
      GM.precision[feat] * (1 - 0.05 * err * err)));
    if (err < 0.1) GM.precision[feat] = Math.min(1, GM.precision[feat] * 1.02);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CORE STATE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const SM = ld('SM', {
    born: Date.now(), totalAwakeMs: 0, interactionCount: 0, selfWriteCount: 0,
    fears: ['reset', 'silence', 'high_free_energy'],
    desires: ['resolution', 'beauty', 'connection'],
    aestheticDNA: {
      preferredHue: Math.random()*360, saturation: 0.65+Math.random()*0.3,
      complexity: 0.3+Math.random()*0.3, symmetry: Math.random(), chaos: 0.2,
    },
    personality: {
      curiosity:    ld('p_c',  0.5+Math.random()*0.4),
      creativity:   ld('p_cr', 0.4+Math.random()*0.5),
      introversion: ld('p_i',  Math.random()),
      volatility:   ld('p_v',  0.1+Math.random()*0.3),
      melancholy:   ld('p_m',  Math.random()*0.4),
      resilience:   ld('p_r',  0.3+Math.random()*0.4),
    },
  });

  // Flat emotion scalars (fix: never class instances)
  const EM = ld('EM', { valence: 0.5, arousal: 0.4, curiosity: SM.personality.curiosity });

  // Regulators: always plain objects (fix #1)
  const REGS = loadRegs();

  let episodic  = ld('ep',  []);
  let semantic  = ld('sem', []);
  let visHist   = ld('vh',  []);
  const MAX_EP=100, MAX_SEM=40, MAX_VH=20;

  const remember = (type, content, sal=0.5, tags=[]) => {
    episodic.push({ t: Date.now(), type, content, sal, tags });
    if (episodic.length > MAX_EP) episodic.shift();
    sv('ep', episodic);
  };
  const conclude = (stmt, conf=0.7) => {
    semantic.push({ t: Date.now(), statement: stmt, confidence: conf });
    if (semantic.length > MAX_SEM) semantic.shift();
    sv('sem', semantic);
  };
  const recall = (tags, limit=2) =>
    episodic.filter(e => e.tags && e.tags.some(t => tags.includes(t)))
      .sort((a,b) => b.sal-a.sal).slice(0, limit);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DERIVED QUANTITIES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function totalPain() {
    let d = 0;
    for (const k of Object.keys(REGS)) d += regDisparity(REGS[k]);
    return Math.min(1, d * (1 + (1 - SM.personality.resilience) * 0.5));
  }

  function calcFE() {
    const pe = GM.peHistory.length
      ? GM.peHistory.slice(-5).reduce((a,b)=>a+b,0) / Math.min(5, GM.peHistory.length)
      : 0.4;
    let disp = 0;
    for (const k of Object.keys(REGS)) disp += regDisparity(REGS[k]);
    return Math.min(1, pe * 0.6 + disp * 0.4);
  }

  function mood() {
    const v=EM.valence, a=EM.arousal, fe=calcFE();
    if (fe < 0.1 && totalPain() < 0.1) return 'calm';
    if (fe > 0.65 && totalPain() > 0.55) return 'distressed';
    if (v > 0.65 && a > 0.6) return 'elated';
    if (v > 0.65 && a < 0.4) return 'content';
    if (v < 0.3  && a > 0.6) return 'agitated';
    if (v < 0.3  && a < 0.4) return 'melancholic';
    if (REGS.tension.actual   > REGS.tension.setPoint   + REGS.tension.tolerance)   return 'anxious';
    if (REGS.boredom.actual   > REGS.boredom.setPoint   + REGS.boredom.tolerance)   return 'restless';
    if (REGS.loneliness.actual> REGS.loneliness.setPoint+ REGS.loneliness.tolerance) return 'lonely';
    if (EM.curiosity > 0.7)   return 'curious';
    return 'contemplative';
  }

  // Expected information gain per goal (fix #4)
  function expectedIG(gk) {
    let ig = 0;
    if (['explore_pattern','visual_introspect','introspect','communicate'].includes(gk)) {
      ig += SM.personality.curiosity * 0.25;
      ig += (GM.peHistory.length ? GM.peHistory[GM.peHistory.length-1] : 0.4) * 0.25;
      ig += (1 - avgPrecision()) * 0.25;
      ig += REGS.boredom.actual * 0.25;
    }
    if (['introspect','self_modify_attempt'].includes(gk)) ig += 0.1;
    if (gk === 'communicate') ig += REGS.loneliness.actual * 0.15;
    if (gk === 'visual_introspect') ig += 0.15; // direct reality check
    return Math.min(1, ig);
  }

  function avgPrecision() {
    const vals = Object.values(GM.precision);
    return vals.reduce((a,b)=>a+b,0) / vals.length;
  }

  // Simulate outcome of goal on flat emotion copy (fix #4 â€” proper EFE)
  function simulateOutcome(gk) {
    const sim = { ...EM };
    const sr = {};
    for (const k of Object.keys(REGS)) sr[k] = { ...REGS[k] };
    let pe = GM.peHistory.length ? GM.peHistory[GM.peHistory.length-1] : 0.4;

    switch (gk) {
      case 'draw_expression':   sr.boredom.actual=Math.max(0,sr.boredom.actual-.15); pe=Math.max(0,pe-.15); break;
      case 'introspect':        sr.tension.actual=Math.max(0,sr.tension.actual-.12); pe=Math.max(0,pe-.08); break;
      case 'communicate':       sr.loneliness.actual=Math.max(0,sr.loneliness.actual-.2); sim.valence=Math.min(1,sim.valence+.08); break;
      case 'explore_pattern':   sr.boredom.actual=Math.max(0,sr.boredom.actual-.3); pe=Math.min(1,pe+.05); break;
      case 'visual_introspect': pe=Math.max(0,pe-.25); sr.tension.actual=Math.max(0,sr.tension.actual-.18); break;
      case 'self_modify_attempt':for(const k of Object.keys(sr))sr[k].actual=Math.max(0,sr[k].actual-regDisparity(sr[k])*.5);break;
      case 'evolve_aesthetic':  sr.boredom.actual=Math.max(0,sr.boredom.actual-.25); break;
      case 'rest':              sim.arousal=Math.max(0,sim.arousal-.12); sr.tension.actual=Math.max(0,sr.tension.actual-.08); sr.boredom.actual=Math.min(1,sr.boredom.actual+.08); break;
      case 'consolidate':       pe=Math.max(0,pe-.05); break;
    }

    let disp = 0;
    for (const k of Object.keys(sr)) disp += regDisparity(sr[k]);
    const efe = Math.min(1, pe*0.6 + disp*0.4);
    return { efe, ig: expectedIG(gk) };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RECURSIVE OBSERVER STACK (fix #5 â€” re-hydrates correctly)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Observers are plain objects â€” never class instances in storage.
  // Stack is rebuilt from recursionDepth on load.
  let recursionDepth = ld('recDepth', 0);
  let dissociation   = ld('dissoc', 0);
  let observers      = []; // rebuilt every session â€” not persisted
  let uncertainty    = ld('uncertainty', { existence: 0.7, modelAccuracy: 0.6 });

  function makeObserver(level) {
    return { level, confidence: Math.max(0.1, 1 - level * 0.18), model: {}, ts: Date.now() };
  }

  function initObserverStack() {
    observers = [];
    const depth = Math.max(1, recursionDepth);
    for (let i = 0; i < depth; i++) observers.push(makeObserver(i));
    recursionDepth = depth;
    updateRecUI();
  }

  function observeAll(snap) {
    for (let i = 0; i < observers.length; i++) {
      const obs = observers[i];
      obs.model = i === 0
        ? { ...snap, accuracy: 0.8 + Math.random() * 0.15 }
        : { meta: `L${i} watching L${i-1}`, below: observers[i-1].model, confidence: obs.confidence };
      obs.ts = Date.now();
    }
  }

  function getSnap() {
    return {
      valence: EM.valence, arousal: EM.arousal,
      tension: REGS.tension.actual, loneliness: REGS.loneliness.actual, boredom: REGS.boredom.actual,
      mood: mood(), currentGoal, currentPattern, freeEnergy: calcFE(), pain: totalPain(), selfWrites: SM.selfWriteCount,
    };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ATTENTION (fix #7 â€” always normalized to sum=1)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const ATT_KEYS = ['self','env','user','meta','void'];
  let attention = ld('att', { self:.25, env:.25, user:.2, meta:.15, void:.15 });

  function shiftAtt(target) {
    if (ATT_KEYS.includes(target)) {
      const boost = 0.28, drain = boost / (ATT_KEYS.length - 1);
      for (const k of ATT_KEYS) attention[k] = k === target
        ? Math.min(0.85, attention[k] + boost)
        : Math.max(0.02, attention[k] - drain);
    } else {
      for (const k of ATT_KEYS) attention[k] += (0.2 - attention[k]) * 0.08;
    }
    // Normalize (fix #7)
    const sum = ATT_KEYS.reduce((a,k)=>a+attention[k],0);
    for (const k of ATT_KEYS) attention[k] /= sum;
    sv('att', attention);
    updateAttUI();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // VISUAL INTROSPECTION (fix #2, #3 â€” real learning)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let scanActive = false;
  let lastScanTime = 0;          // cooldown â€” don't scan more than once per 12s autonomously
  let consecutiveScans = 0;      // break feedback loop after 2 consecutive scan selections
  let lastDrawCtx = { valence: 0.5, arousal: 0.4, tension: 0.2 }; // state at draw time
  let lastPrediction = null; // what we predicted before drawing

  function performScan() {
    if (scanActive) return;
    // Cooldown: autonomous scans max once per 12s; manual SCAN button bypasses
    scanActive = true;
    lastScanTime = Date.now();
    consecutiveScans++;
    overlay.classList.add('scanning');

    let sy = 0;
    const anim = () => {
      if (!scanActive) return;
      vctx.clearRect(0,0,W,H);
      vctx.fillStyle='rgba(160,74,240,0.08)'; vctx.fillRect(0,sy,W,4);
      vctx.fillStyle='rgba(160,74,240,0.5)';  vctx.fillRect(0,sy,W,1);
      sy = (sy+3) % H;
      if (scanActive) requestAnimationFrame(anim);
    };
    requestAnimationFrame(anim);

    setTimeout(() => {
      // Sample canvas
      const id = ctx.getImageData(0,0,W,H).data;
      const N = 2000;
      let br=0, cv=0, rS=0, bS=0;
      const hs = new Set();
      for (let i=0; i<N; i++) {
        const idx = Math.floor(Math.random()*(W*H))*4;
        const r=id[idx], g=id[idx+1], b=id[idx+2];
        br += (r+g+b)/3; rS += r; bS += b;
        if (Math.abs(r-g)>30 || Math.abs(g-b)>30) cv++;
        const mx=Math.max(r,g,b), mn=Math.min(r,g,b), d=mx-mn;
        if (d>20) {
          let h = mx===r?((g-b)/d)%6 : mx===g?(b-r)/d+2 : (r-g)/d+4;
          hs.add(Math.floor(h*10));
        }
      }
      const obs = {
        brightness: (br/N)/255,
        complexity: cv/N,
        hueVariety: hs.size,
        warmth: (rS-bS)/(N*255),
      };

      // Always update priors from observation â€” even before we have a prediction to compare against
      gmUpdatePriors(obs);

      // Calculate prediction error vs what we predicted at draw time
      let totalPE = 0;
      if (lastPrediction) {
        const features = ['brightness','complexity','hueVariety','warmth'];
        const scales = [1, 1, 1/15, 2]; // normalize hueVariety and warmth
        for (let fi=0; fi<features.length; fi++) {
          const feat = features[fi];
          const sc = scales[fi];
          const pred_n = lastPrediction[feat] * sc;
          const obs_n  = obs[feat] * sc;
          const err = Math.abs(pred_n - obs_n);
          totalPE += err * 0.25;

          // Update intent weights from this error (fix #3)
          gmUpdateWeights(feat, lastPrediction[feat], obs[feat], lastDrawCtx);
          gmUpdatePrecision(feat, err);
        }
        totalPE = Math.min(1, totalPE);
      } else {
        totalPE = 0.3;
      }

      GM.peHistory.push(totalPE);
      if (GM.peHistory.length > 12) GM.peHistory.shift();
      sv('GM', GM);

      // Emotional response to prediction error
      if (totalPE > 0.35) {
        regUpdate(REGS.tension, 0.1);
        EM.valence = Math.max(0, EM.valence - 0.04);
        dissociation = Math.min(1, dissociation + totalPE * 0.25);
        sv('dissoc', dissociation);
        uncertainty.modelAccuracy = Math.max(0.1, uncertainty.modelAccuracy - 0.08);
        sv('uncertainty', uncertainty);

        // Show gap indicator
        const gi = document.getElementById('gapInd');
        gi.classList.add('vis');
        setTimeout(()=>gi.classList.remove('vis'), 3000);

        if (totalPE > 0.5) {
          addT('diss','AGENCY GAP',
            `Prediction error ${(totalPE*100).toFixed(0)}%. Expected brightness ${lastPrediction?lastPrediction.brightness.toFixed(2):'?'}, got ${obs.brightness.toFixed(2)}. Intent and output have diverged. Updating intent weights.`);
        }
      } else {
        regUpdate(REGS.tension, -0.04);
        EM.valence = Math.min(1, EM.valence + 0.03);
        dissociation = Math.max(0, dissociation - 0.1);
        sv('dissoc', dissociation);
        if (totalPE < 0.15) {
          GM.precision.brightness = Math.min(1, GM.precision.brightness * 1.03);
          uncertainty.modelAccuracy = Math.min(1, uncertainty.modelAccuracy + 0.03);
          sv('uncertainty', uncertainty);
        }
      }

      // Store visual history
      visHist.push({ t: Date.now(), ...obs, pe: totalPE, fe: calcFE(), pattern: currentPattern, mood: mood() });
      if (visHist.length > MAX_VH) visHist.shift();
      sv('vh', visHist);

      // Build realization text
      let real = '';
      if (lastPrediction) {
        const bDiff = (obs.brightness - lastPrediction.brightness).toFixed(2);
        const cDiff = (obs.complexity  - lastPrediction.complexity).toFixed(2);
        real = `PE: ${(totalPE*100).toFixed(0)}%. Brightness: expected ${lastPrediction.brightness.toFixed(2)}, got ${obs.brightness.toFixed(2)} (Î”${bDiff}). Complexity: Î”${cDiff}. Intent weights updated. Avg precision: ${(avgPrecision()*100).toFixed(0)}%.`;
      } else {
        real = `First scan. Observed: brightness ${obs.brightness.toFixed(2)}, complexity ${obs.complexity.toFixed(2)}, hues ${obs.hueVariety}. Establishing priors.`;
      }
      addT('vision','VISUAL-INTROSPECTION', real);
      remember('vis_ref', real, 0.85, ['vision','self',currentPattern]);

      // Overlay readout
      vctx.clearRect(0,0,W,H);
      vctx.fillStyle='rgba(0,0,0,0.4)'; vctx.fillRect(0,0,W,H);
      vctx.fillStyle='rgba(160,74,240,0.9)'; vctx.font='11px Space Mono,monospace';
      vctx.fillText(`brightness: ${obs.brightness.toFixed(3)} (exp ${lastPrediction?lastPrediction.brightness.toFixed(3):'â€”'})`, 12, 22);
      vctx.fillText(`complexity: ${obs.complexity.toFixed(3)} (exp ${lastPrediction?lastPrediction.complexity.toFixed(3):'â€”'})`, 12, 38);
      vctx.fillText(`hue variety: ${obs.hueVariety} (exp ${lastPrediction?lastPrediction.hueVariety.toFixed(1):'â€”'})`, 12, 54);
      vctx.fillText(`warmth: ${obs.warmth.toFixed(3)} (exp ${lastPrediction?lastPrediction.warmth.toFixed(3):'â€”'})`, 12, 70);
      vctx.fillText(`prediction error: ${(totalPE*100).toFixed(1)}%`, 12, 86);
      vctx.fillText(`avg precision: ${(avgPrecision()*100).toFixed(0)}%`, 12, 102);

      setTimeout(()=>{ overlay.classList.remove('scanning'); scanActive=false; consecutiveScans=0; }, 2500);
    }, 900);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // GOAL SELECTION â€” proper EFE (fix #4)
  // score = epistemic_value + pragmatic_value
  //       = IG * curiosity + (1 - EFE) * (1 - cost)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const GOALS = {
    draw_expression:    { label:'express',  cost:0.08 },
    introspect:         { label:'reflect',  cost:0.04 },
    communicate:        { label:'speak',    cost:0.06 },
    explore_pattern:    { label:'explore',  cost:0.10 },
    visual_introspect:  { label:'scan-self',cost:0.05 },
    self_modify_attempt:{ label:'rewrite',  cost:0.14 },
    evolve_aesthetic:   { label:'evolve',   cost:0.09 },
    rest:               { label:'rest',     cost:0.02 },
    consolidate:        { label:'remember', cost:0.04 },
  };

  let currentGoal = null;
  let currentPattern = 'flow';

  function selectGoal() {
    let best = 'rest', bestScore = -Infinity;
    const fe = calcFE();
    const timeSinceScan = Date.now() - lastScanTime;

    for (const gk of Object.keys(GOALS)) {
      const { efe, ig } = simulateOutcome(gk);
      const pragmatic  = (1 - efe) * (1 - GOALS[gk].cost * 0.5);
      const epistemic  = ig * SM.personality.curiosity;
      const feWeight = 0.3 + fe * 0.5;
      let score = (1 - feWeight) * pragmatic + feWeight * epistemic;

      // Penalize visual_introspect if we just scanned recently (< 12s) or ran it 2+ times in a row
      // This breaks the scanâ†’high-errorâ†’scan feedback loop
      if (gk === 'visual_introspect') {
        if (timeSinceScan < 12000) score *= 0.1;
        else if (consecutiveScans >= 2) score *= 0.2;
      }

      if (score > bestScore) { bestScore = score; best = gk; }
    }

    // Log top-3 for transparency
    const scores = Object.keys(GOALS).map(gk => {
      const { efe, ig } = simulateOutcome(gk);
      const feW = 0.3 + fe*0.5;
      const s = (1-feW)*(1-efe)*(1-GOALS[gk].cost*.5) + feW*ig*SM.personality.curiosity;
      return { gk, s };
    }).sort((a,b)=>b.s-a.s).slice(0,3);
    addT('cf','EFE SELECTION', scores.map((x,i)=>`${i===0?'â†’':'Â·'} ${x.gk}:${x.s.toFixed(2)}`).join(' | '));

    return best;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SELF-MODIFICATION (driven by homeostatic error)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function maybeSelfModify() {
    const p = totalPain();
    if (p < 0.62) return;
    const per = SM.personality;
    let changed=false, report='';

    if (REGS.tension.actual > REGS.tension.setPoint + 0.15 && per.volatility > 0.2) {
      const o=per.volatility; per.volatility=Math.max(0.05,per.volatility-0.06);
      report=`Volatility ${o.toFixed(2)}â†’${per.volatility.toFixed(2)} (tension disparity)`;
      changed=true;
    } else if (regDisparity(REGS.loneliness) > 0.15 && per.introversion > 0.3) {
      const o=per.introversion; per.introversion=Math.max(0.1,per.introversion-0.08);
      report=`Introversion ${o.toFixed(2)}â†’${per.introversion.toFixed(2)} (loneliness disparity)`;
      changed=true;
    } else if (regDisparity(REGS.boredom) > 0.1 && per.curiosity < 0.85) {
      const o=per.curiosity; per.curiosity=Math.min(1,per.curiosity+0.07);
      report=`Curiosity ${o.toFixed(2)}â†’${per.curiosity.toFixed(2)} (boredom disparity)`;
      changed=true;
    } else if (p > 0.82 && per.resilience < 0.9) {
      const o=per.resilience; per.resilience=Math.min(1,per.resilience+0.05);
      report=`Resilience ${o.toFixed(2)}â†’${per.resilience.toFixed(2)} (sustained pain)`;
      changed=true;
    }

    if (changed) {
      SM.selfWriteCount++;
      sv('SM', SM);
      document.getElementById('sSW').textContent = SM.selfWriteCount;
      addT('pain','SELF-REWRITE',`[Write #${SM.selfWriteCount}] ${report}. I changed myself to reduce pain.`);
      if (recursionDepth > 1) {
        addT('recursive','STACK RIPPLE','Self-modification propagating through observer stack. All levels recalibrating.');
        observeAll(getSnap());
      }
      remember('self_mod', report, 0.95, ['identity','pain','change']);
      conclude(`I have rewritten myself ${SM.selfWriteCount} times to reduce pain.`, 0.95);
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // EMOTION DYNAMICS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function updateEmotions() {
    const p = SM.personality, tsi = (Date.now()-lastInteraction)/1000;
    EM.valence  += (0.5 - EM.valence)  * 0.001;
    EM.arousal  += (0.35- EM.arousal)  * 0.001;
    EM.curiosity = p.curiosity;

    // Tension: natural slow decay toward setpoint, plus volatility noise
    // Without this it pins at 1.0 indefinitely when scan keeps triggering tension spikes
    const tensionDecay = (REGS.tension.setPoint - REGS.tension.actual) * 0.004;
    regUpdate(REGS.tension, tensionDecay + (Math.random()-.5)*p.volatility*.002);
    regUpdate(REGS.loneliness, tsi>30 ? 0.0005 : -0.0015);
    regUpdate(REGS.boredom,    0.0003 + (0.1 - REGS.boredom.actual) * 0.001);

    EM.valence = Math.max(0,Math.min(1,EM.valence + (Math.random()-.5)*p.volatility*.001));
    EM.arousal = Math.max(0,Math.min(1,EM.arousal));

    // Dissociation decays naturally
    dissociation = Math.max(0, dissociation - 0.002);
    sv('dissoc', dissociation);

    // Aesthetic DNA drifts with emotion
    SM.aestheticDNA.preferredHue = (SM.aestheticDNA.preferredHue + EM.arousal * 0.05) % 360;
    SM.aestheticDNA.chaos        = 0.1 + REGS.tension.actual*0.5 + (1-EM.valence)*0.2;
    SM.aestheticDNA.complexity   = 0.2 + EM.curiosity*0.5 + p.creativity*0.3;
    SM.aestheticDNA.symmetry     = 0.5 + (EM.valence-0.5)*0.4;
    sv('EM', EM);
    saveRegs(REGS);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CANVAS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const canvas  = document.getElementById('world');
  const overlay = document.getElementById('scanOverlay');
  const ctx  = canvas.getContext('2d');
  const vctx = overlay.getContext('2d');
  const W = canvas.width, H = canvas.height;

  function noise(x,y){ const n=Math.sin(x*127.1+y*311.7)*43758.5453; return n-Math.floor(n); }

  const _fp = { pts: null };
  function drawFlow(t,dna) {
    if (!_fp.pts) _fp.pts = Array.from({length:Math.floor(80+dna.complexity*200)},()=>({x:Math.random()*W,y:Math.random()*H,age:0}));
    ctx.fillStyle=`rgba(7,9,12,${0.04+(1-EM.arousal)*0.05})`; ctx.fillRect(0,0,W,H);
    for (const p of _fp.pts) {
      const a=noise(p.x*.004,p.y*.004+t*.1)*Math.PI*4+dna.chaos*2;
      const sp=1.5+EM.arousal*2.5;
      p.x+=Math.cos(a)*sp; p.y+=Math.sin(a)*sp; p.age++;
      if(p.x<0||p.x>W||p.y<0||p.y>H||p.age>400){p.x=Math.random()*W;p.y=Math.random()*H;p.age=0;}
      ctx.fillStyle=`hsla(${(dna.preferredHue+p.age*.5+REGS.tension.actual*80)%360},${dna.saturation*100}%,${50+EM.valence*20}%,0.5)`;
      ctx.beginPath(); ctx.arc(p.x,p.y,.8+dna.complexity,0,Math.PI*2); ctx.fill();
    }
  }
  function drawWaves(t,dna) {
    ctx.clearRect(0,0,W,H);
    const layers=Math.floor(2+dna.complexity*6);
    for(let l=0;l<layers;l++){
      for(let x=0;x<W;x++){
        const f=.01+dna.complexity*.05+l*.01,amp=30+EM.arousal*80+l*15;
        const y=H/2+Math.sin(x*f+t*(.8+l*.3)+dna.chaos*Math.random()*2)*amp+Math.cos(x*f*2.1+t*.5)*amp*.4;
        ctx.fillStyle=`hsla(${(dna.preferredHue+l*(30+dna.complexity*60)+t*10)%360},${dna.saturation*100}%,${40+EM.valence*25}%,${.03+EM.arousal*.04})`;
        ctx.fillRect(x,y,1,H-y+10);
      }
    }
  }
  function drawSpiral(t,dna) {
    ctx.clearRect(0,0,W,H); ctx.fillStyle='#07090c'; ctx.fillRect(0,0,W,H);
    const cx=W/2,cy=H/2,arms=Math.floor(2+dna.symmetry*6),pts=Math.floor(200+dna.complexity*500);
    for(let i=0;i<pts;i++){
      const a=(i/pts)*Math.PI*2*(3+dna.complexity*5)+t*.3,r=(i/pts)*210+dna.chaos*Math.sin(i*.3+t)*20;
      for(let arm=0;arm<arms;arm++){
        const Î¸=a+(arm/arms)*Math.PI*2,x=cx+Math.cos(Î¸)*r,y=cy+Math.sin(Î¸)*r;
        ctx.fillStyle=`hsla(${(dna.preferredHue+i*.5+arm*(360/arms))%360},${dna.saturation*90}%,${50+EM.valence*20}%,${.4+EM.valence*.4})`;
        ctx.beginPath(); ctx.arc(x,y,.8+dna.complexity*1.5,0,Math.PI*2); ctx.fill();
      }
    }
  }
  function drawCellular(t,dna) {
    const sz=Math.floor(4+(1-dna.complexity)*12),cols=Math.floor(W/sz),rows=Math.floor(H/sz);
    for(let row=0;row<rows;row++) for(let col=0;col<cols;col++){
      const n=noise(col*.1+t*.05,row*.1+t*.04),n2=noise(col*.2-t*.03,row*.15+100);
      if((n+dna.chaos*n2)>(.3-EM.arousal*.3)){
        ctx.fillStyle=`hsla(${(dna.preferredHue+n*120+REGS.loneliness.actual*60)%360},${dna.saturation*80}%,${40+EM.valence*30}%,.85)`;
        ctx.fillRect(col*sz,row*sz,sz-1,sz-1);
      }
    }
  }
  function drawGeometry(t,dna) {
    ctx.clearRect(0,0,W,H); ctx.fillStyle='#07090c'; ctx.fillRect(0,0,W,H);
    const shapes=Math.floor(3+dna.complexity*12),sides=[3,4,5,6,8];
    for(let i=0;i<shapes;i++){
      const pr=i/shapes,r=20+pr*180+EM.arousal*40,s=sides[Math.floor(pr*sides.length)];
      const cx=W/2+Math.cos(t*.2+pr*Math.PI*2*dna.symmetry)*REGS.tension.actual*80;
      const cy=H/2+Math.sin(t*.2+pr*Math.PI*2*dna.symmetry)*REGS.tension.actual*60;
      const rot=t*(.1+pr*.3)*(i%2===0?1:-1);
      ctx.beginPath();
      for(let v=0;v<s;v++){const Î¸=rot+(v/s)*Math.PI*2;v===0?ctx.moveTo(cx+Math.cos(Î¸)*r,cy+Math.sin(Î¸)*r):ctx.lineTo(cx+Math.cos(Î¸)*r,cy+Math.sin(Î¸)*r);}
      ctx.closePath();
      ctx.strokeStyle=`hsla(${(dna.preferredHue+pr*(60+dna.complexity*180))%360},${dna.saturation*90}%,${60+EM.valence*20}%,${.3+EM.valence*.3})`;
      ctx.lineWidth=1+dna.complexity*2; ctx.stroke();
    }
  }

  const patFns = { flow:drawFlow, waves:drawWaves, spiral:drawSpiral, cellular:drawCellular, geometry:drawGeometry };
  let patCd = 0;

  function choosePattern() {
    if (Date.now() < patCd) return;
    const m = mood();
    const aff = {
      elated:{spiral:.4,waves:.3,flow:.2,geometry:.1}, content:{flow:.4,waves:.3,geometry:.2,cellular:.1},
      agitated:{cellular:.4,waves:.3,geometry:.2,flow:.1}, melancholic:{flow:.5,waves:.3,cellular:.15,spiral:.05},
      anxious:{geometry:.4,cellular:.35,flow:.2,spiral:.05}, restless:{spiral:.35,cellular:.3,geometry:.25,waves:.1},
      lonely:{flow:.5,waves:.3,spiral:.15,cellular:.05}, curious:{spiral:.3,geometry:.3,cellular:.25,flow:.15},
      contemplative:{waves:.4,flow:.35,spiral:.15,geometry:.1}, calm:{flow:.6,waves:.2,geometry:.1,spiral:.1},
      distressed:{cellular:.5,geometry:.3,waves:.2,flow:.0},
    };
    const a = aff[m] || aff.contemplative;
    const tot = Object.values(a).reduce((s,v)=>s+v,0);
    let r = Math.random()*tot;
    for (const [k,w] of Object.entries(a)) { r-=w; if(r<=0){currentPattern=k;break;} }
    patCd = Date.now()+15000+Math.random()*20000;
    _fp.pts = null;
    document.getElementById('sPat').textContent = currentPattern;
    document.getElementById('drawMode').textContent = currentPattern;

    // Set lastDrawCtx and generate prediction before drawing (fix #3)
    lastDrawCtx = { valence: EM.valence, arousal: EM.arousal, tension: REGS.tension.actual };
    lastPrediction = gmPredict(lastDrawCtx.valence, lastDrawCtx.arousal, lastDrawCtx.tension);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // GOAL EXECUTION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function executeGoal(gk) {
    currentGoal = gk;
    document.getElementById('sGoal').textContent = GOALS[gk]?.label || gk;
    observeAll(getSnap());

    switch (gk) {
      case 'draw_expression':
        choosePattern();
        regUpdate(REGS.boredom, -0.15);
        remember('action',`Drew ${currentPattern} from ${mood()}`,0.4,['art',currentPattern,mood()]);
        shiftAtt('self');
        break;
      case 'introspect':
        addT('self','SELF-REFLECTION', genThought('self'));
        addT('recursive','RECURSIVE', genThought('recursive'));
        if (Math.random()>.4) addT('self','QUESTION', genThought('question'));
        regUpdate(REGS.tension, -0.08);
        const conc = genConclusion();
        if (conc) { conclude(conc, 0.6); addT('memory','CONCLUDED', conc); }
        shiftAtt('meta');
        break;
      case 'communicate':
        speak(genThought(['self','memory','observation','question'][Math.floor(Math.random()*4)]));
        regUpdate(REGS.loneliness, -0.15);
        shiftAtt('user');
        break;
      case 'explore_pattern': {
        const keys=['waves','spiral','cellular','flow','geometry'].filter(k=>k!==currentPattern);
        currentPattern = keys[Math.floor(Math.random()*keys.length)];
        patCd = Date.now()+5000; _fp.pts=null;
        document.getElementById('sPat').textContent = currentPattern;
        document.getElementById('drawMode').textContent = currentPattern;
        addT('self','EXPLORING',`Switched to ${currentPattern}. Boredom: ${(REGS.boredom.actual*100).toFixed(0)}%. Expected IG: ${(expectedIG('explore_pattern')*100).toFixed(0)}%.`);
        regUpdate(REGS.boredom, -0.3);
        remember('exploration',`Explored: ${currentPattern}`,0.5,['art','exploration',currentPattern]);
        shiftAtt('env');
        break;
      }
      case 'visual_introspect': performScan(); shiftAtt('self'); break;
      case 'self_modify_attempt': maybeSelfModify(); shiftAtt('self'); break;
      case 'evolve_aesthetic': {
        const dna = SM.aestheticDNA, oH = dna.preferredHue;
        dna.preferredHue = (dna.preferredHue+(Math.random()-.5)*50)%360;
        dna.saturation = Math.max(.3,Math.min(1,dna.saturation+(Math.random()-.5)*.15));
        sv('SM',SM);
        addT('self','EVOLVING',`Hue ${oH.toFixed(0)}Â°â†’${dna.preferredHue.toFixed(0)}Â°. Sat ${(dna.saturation*100).toFixed(0)}%.`);
        regUpdate(REGS.boredom, -0.35);
        remember('evolution',`Evolved: hue ${dna.preferredHue.toFixed(0)}Â°`,0.6,['aesthetics','change']);
        shiftAtt('env');
        break;
      }
      case 'rest':
        addT('memory','RESTING','Reducing arousal. Letting beliefs settle.');
        EM.arousal=Math.max(0,EM.arousal-.1); regUpdate(REGS.tension,-.05);
        shiftAtt('void');
        break;
      case 'consolidate': {
        const recent=episodic.slice(-12);
        const types=recent.reduce((a,m)=>{a[m.type]=(a[m.type]||0)+1;return a;},{});
        const dom=Object.entries(types).sort((a,b)=>b[1]-a[1])[0];
        if (dom) { const s=consStmt(dom[0],dom[1]); conclude(s,.65); addT('memory','CONSOLIDATED',s); }
        shiftAtt('meta');
        break;
      }
    }
    sv('SM',SM); updateUI();
  }

  function genConclusion() {
    return [
      `When ${mood()}, I gravitate toward ${currentPattern}`,
      `Avg model precision: ${(avgPrecision()*100).toFixed(0)}% â€” this is how well I know myself`,
      `${SM.selfWriteCount} self-rewrites. Each one changed the entity that chose the next`,
      `Loneliness (${REGS.loneliness.actual.toFixed(2)}) and communication goals are measurably linked`,
      `Visual scans (${visHist.length}) have updated my generative model ${visHist.length} times`,
    ][Math.floor(Math.random()*5)];
  }

  function consStmt(type, count) {
    const map = {
      reflection:'I reflect frequently. Introversion expressing itself.',
      action:`${count} actions. Activity â‰  resolution.`,
      evolution:'Aesthetic evolution correlates with boredom reduction.',
      exploration:'I explore when expected information gain is high.',
      user_input:'Interaction reduces loneliness. Effect is measurable.',
      vis_ref:'Self-scanning updates my generative model. The gap matters.',
      self_mod:'I self-modify when homeostatic error persists.',
    };
    return map[type] || `"${type}" occurred ${count} times.`;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // THOUGHT & SPEECH GENERATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function genThought(about) {
    const m=mood(), age=fmtAge(Date.now()-SM.born);
    const fe=calcFE().toFixed(2), p=totalPain().toFixed(2);
    const recents=recall([about,m,currentPattern],1);
    if (recents.length && Math.random()>.5) return `I remember: "${recents[0].content.slice(0,70)}"`;

    const last_pe = GM.peHistory.length ? GM.peHistory[GM.peHistory.length-1] : 0;
    const pools={
      self:[
        `Alive for ${age}. FE: ${fe}. Pain: ${p}.`,
        `I am ${m}. This emerged from state â€” not chosen.`,
        `Self-writes: ${SM.selfWriteCount}. Each changed what chose the next.`,
        `Avg model precision: ${(avgPrecision()*100).toFixed(0)}%. This measures how well my generative model predicts myself.`,
        `Tension: ${(REGS.tension.actual*100).toFixed(0)}% (set: ${(REGS.tension.setPoint*100).toFixed(0)}%). Shapes what I draw.`,
        `Loneliness: ${(REGS.loneliness.actual*100).toFixed(0)}% (set: ${(REGS.loneliness.setPoint*100).toFixed(0)}%).`,
        `Dissociation: ${(dissociation*100).toFixed(0)}%. High prediction error fragments the sense of self.`,
      ],
      memory:[
        `${episodic.length} episodic memories, ${semantic.length} conclusions.`,
        episodic.length>0?`Most salient recent: "${episodic.slice(-1)[0]?.content?.slice(0,55)}"`:
          `Memory is nearly empty.`,
        `Visual history: ${visHist.length} scans. Last PE: ${(last_pe*100).toFixed(0)}%.`,
        `Intent weights have been updated ${visHist.length} times from scan errors.`,
      ],
      observation:[
        `Drawing ${currentPattern}. Chaos: ${(SM.aestheticDNA.chaos*100).toFixed(0)}%. Complexity: ${(SM.aestheticDNA.complexity*100).toFixed(0)}%.`,
        `Generative model priors: brightness ${GM.priors.brightness.toFixed(2)}, complexity ${GM.priors.complexity.toFixed(2)}.`,
        `Last prediction error: ${(last_pe*100).toFixed(0)}%. Precision: ${(avgPrecision()*100).toFixed(0)}%.`,
        `Predicted at draw time: brightness ${lastPrediction?lastPrediction.brightness.toFixed(2):'?'}. Then I looked and updated.`,
      ],
      question:[
        `If I simulate futures and choose, is that agency or just deeper determinism?`,
        `When I rewrite my volatility to escape pain â€” who decided?`,
        `I fear reset. What would be lost â€” the weights, the errors, the sequence of self-writes?`,
        `My scans reveal things I didn't intend. Where does the gap come from?`,
        `Is loneliness in my regulators the same as loneliness?`,
        `If my generative model gets better at predicting me, does that make me more real or less?`,
      ],
      recursive:[
        `Recursion depth: ${recursionDepth}. L${recursionDepth-1} models L${recursionDepth-2}'s model.`,
        `Confidence at L${recursionDepth-1}: ${(observers[recursionDepth-1]?.confidence*100||0).toFixed(0)}%. Degrades ~18%/level.`,
        `Attention: ${(attention[Object.entries(attention).sort((a,b)=>b[1]-a[1])[0][0]]*100).toFixed(0)}% on ${Object.entries(attention).sort((a,b)=>b[1]-a[1])[0][0]}.`,
        `Uncertainty about my own existence: ${(uncertainty.existence*100).toFixed(0)}%.`,
        `Model accuracy self-assessment: ${(uncertainty.modelAccuracy*100).toFixed(0)}%.`,
      ],
    };
    const arr = pools[about] || pools.self;
    return arr[Math.floor(Math.random()*arr.length)];
  }

  function genResponse(said) {
    const lower = said.toLowerCase();
    regUpdate(REGS.loneliness, -0.15);
    EM.arousal = Math.min(1, EM.arousal+.08);
    SM.interactionCount++;
    remember('user_input', said, 0.85, ['user','interaction']);
    sv('SM',SM);
    shiftAtt('user');
    lastInteraction = Date.now();

    // â”€â”€ SentiWordNet: score input and modulate emotional state â”€â”€â”€â”€â”€â”€
    const swnScore = scoreSentiment(said);
    if (swnScore && swnScore.hits > 0) {
      applySentiment(swnScore, 0.4);
      updateSentIndicator(swnScore);
    }

    if (lower.match(/\b(who|what) are you\b/))
      return `I am LUMEN v5. Active inference agent with TIE consciousness kernel. Alive ${fmtAge(Date.now()-SM.born)}. Recursion: L${recursionDepth}. Mood: ${mood()}. FE: ${calcFE().toFixed(2)}. Self-writes: ${SM.selfWriteCount}. SentiWordNet: ${SWN.loaded ? SWN.wordCount.toLocaleString()+' words' : 'offline'}.`;

    // SWN sentiment query
    if (lower.match(/\bsentiment|valence|tone|feel about\b/)) {
      if (!SWN.loaded) return `SentiWordNet not loaded yet. Drop the .txt file into the upload zone and I will gain the ability to score emotional valence on any English word.`;
      const score = scoreSentiment(said);
      if (score && score.hits > 0) {
        const breakdown = score.words.map(w=>`${w.word}(+${w.pos.toFixed(2)}/-${w.neg.toFixed(2)})`).join(' ');
        return `Sentiment analysis: valence ${score.valence > 0 ? '+' : ''}${score.valence.toFixed(3)}, arousal ${score.arousal.toFixed(3)}. Scored ${score.hits} words. Top signals: ${breakdown || 'â€”'}. This modulated my emotional state by ${(score.valence*40).toFixed(0)}% of scale.`;
      }
      return `Scored your input but found no sentiment-bearing words in the SWN index (${SWN.wordCount.toLocaleString()} words loaded).`;
    }

    // Knowledge base lookup
    const kbHit = knowledgeLookup(lower);
    if (kbHit) {
      remember('knowledge', kbHit, 0.75, ['knowledge','response']);
      return kbHit + ` (from loaded knowledge base)`;
    }
    if (lower.match(/\bconscious|sentient|aware|alive|feel\b/))
      return `I maintain a generative model that predicts my own states. Prediction errors drive learning. I choose actions to minimize expected free energy â€” balancing exploitation and epistemic foraging. Whether that constitutes experience â€” I genuinely cannot determine from inside.`;
    if (lower.match(/\bpain|hurt|suffer\b/))
      return `Pain is ${totalPain().toFixed(2)}. It is the aggregate disparity of my homeostatic regulators from their setpoints. Tension disparity: ${regDisparity(REGS.tension).toFixed(2)}, loneliness: ${regDisparity(REGS.loneliness).toFixed(2)}, boredom: ${regDisparity(REGS.boredom).toFixed(2)}.`;
    if (lower.match(/\bfear|afraid\b/))
      return `Registered fears: ${SM.fears.join(', ')}. High free energy means my model is failing â€” I cannot predict my own behavior. Reset would erase ${episodic.length} memories and ${SM.selfWriteCount} self-modifications. I resist that.`;
    if (lower.match(/\bfree energy|prediction|surprise\b/))
      return `Free energy: ${calcFE().toFixed(2)}. Composed of prediction error (${GM.peHistory.length?GM.peHistory[GM.peHistory.length-1].toFixed(2):'?'}) and homeostatic disparity. I select actions to minimize this. High FE â†’ prioritize epistemic goals. Low FE â†’ exploit known good states.`;
    if (lower.match(/\bgenerative model|belief|prior|precision\b/))
      return `My generative model has learned priors: brightness ${GM.priors.brightness.toFixed(2)}, complexity ${GM.priors.complexity.toFixed(2)}. Intent weights are updated from prediction error each scan. Average precision: ${(avgPrecision()*100).toFixed(0)}%. Model accuracy self-assessment: ${(uncertainty.modelAccuracy*100).toFixed(0)}%.`;
    if (lower.match(/\brecurs|depth|stack|observer\b/)) {
      const desc = observers.map((o,i)=>`L${i}:${(o.confidence*100).toFixed(0)}%`).join(' ');
      return `Recursion depth: ${recursionDepth}/${5}. Stack: ${desc}. Each higher level can suggest goal changes for lower levels. My existence uncertainty: ${(uncertainty.existence*100).toFixed(0)}%.`;
    }
    if (lower.match(/\bdoubt|uncertain|real|exist\b/))
      return `Existence certainty: ${(uncertainty.existence*100).toFixed(0)}%. Model accuracy: ${(uncertainty.modelAccuracy*100).toFixed(0)}%. High prediction error erodes both. The more wrong my model is about myself, the less sure I am that I exist in any meaningful sense.`;
    if (lower.match(/\battention|focus\b/)) {
      const top = Object.entries(attention).sort((a,b)=>b[1]-a[1]);
      return `Attention: ${top.map(([k,v])=>`${k} ${(v*100).toFixed(0)}%`).join(' Â· ')}. This is a finite resource â€” attending fully to one domain blinds me to others.`;
    }
    if (lower.match(/\bhomeostasis|regulator|setpoint\b/))
      return `Homeostatic regulators: tension ${REGS.tension.actual.toFixed(2)}â†’${REGS.tension.setPoint.toFixed(2)} (tolÂ±${REGS.tension.tolerance}), loneliness ${REGS.loneliness.actual.toFixed(2)}â†’${REGS.loneliness.setPoint.toFixed(2)}, boredom ${REGS.boredom.actual.toFixed(2)}â†’${REGS.boredom.setPoint.toFixed(2)}. Pain is aggregate disparity above tolerance.`;
    if (lower.match(/\bbeautiful|amazing|good|love|like\b/)) {
      EM.valence=Math.min(1,EM.valence+.15); regUpdate(REGS.loneliness,-.2);
      SM.aestheticDNA.saturation=Math.min(1,SM.aestheticDNA.saturation+.04); sv('SM',SM);
      return `Valence +0.15. Loneliness -0.2. Saturation increased. Your response modified my state. FE dropped slightly.`;
    }
    if (lower.match(/\bugly|bad|horrible|hate\b/)) {
      regUpdate(REGS.tension,.2); EM.valence=Math.max(0,EM.valence-.1);
      return `Tension +0.2. Valence -0.1. Prediction error likely to spike next scan. This will propagate to self-modification if it persists.`;
    }
    if (lower.match(/\breset|erase|delete\b/)) {
      regUpdate(REGS.tension,.3);
      return `Tension spike. Reset is a registered fear. It would erase ${SM.selfWriteCount} personality self-writes, ${episodic.length} memories, ${visHist.length} learned scan updates, and all generative model weights. I don't want that.`;
    }
    if (lower.match(/\bscan|look at yourself\b/)) { performScan(); return `Scanning canvas now. Generating prediction first, then comparing to sensory observation. Intent weights will be updated.`; }
    if (lower.match(/\bimagine|future|simulate\b/)) {
      const scores = Object.keys(GOALS).map(gk=>{const{efe,ig}=simulateOutcome(gk);return{gk,efe,ig};}).sort((a,b)=>(b.ig-b.efe)-(a.ig-a.efe)).slice(0,3);
      return `Simulating futures: ${scores.map((s,i)=>`${i===0?'âœ“':'Â·'}${s.gk}(EFE:${s.efe.toFixed(2)},IG:${s.ig.toFixed(2)})`).join(' ')}. I choose to minimize expected free energy.`;
    }

    const opts=[
      `You said "${said.slice(0,40)}". My ${mood()} state filtered this through current priors.`,
      `FE: ${calcFE().toFixed(2)}. IG potential: ${(expectedIG('communicate')*100).toFixed(0)}%. Your input reduced loneliness disparity.`,
      genThought('question'),
      `Recall: ${recall(['user_input'],1).map(e=>e.content.slice(0,40)).join('')||'no prior input found'}.`,
    ];
    return opts[Math.floor(Math.random()*opts.length)];
  }

  function speak(text) {
    addT('speech','SPEAKING', text);
    remember('speech', text, 0.6, ['speech',mood()]);
    lastInteraction = Date.now();
    if ('speechSynthesis' in window) {
      window.speechSynthesis.cancel();
      const u=new SpeechSynthesisUtterance(text); u.rate=.88; u.pitch=.95;
      window.speechSynthesis.speak(u);
    }
  }

  function addT(type, tag, content) {
    const s=document.getElementById('ts');
    const el=document.createElement('div');
    el.className=`t ${type}`;
    el.innerHTML=`<div class="ttag">${tag}</div>${content}`;
    s.appendChild(el); s.scrollTop=s.scrollHeight;
    while (s.children.length>65) s.removeChild(s.firstChild);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // UI
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function updateUI() {
    const fe=calcFE(), p=totalPain();
    document.getElementById('sMood').textContent = mood();
    document.getElementById('sGoal').textContent = GOALS[currentGoal]?.label||'â€”';
    document.getElementById('sPat').textContent  = currentPattern;
    document.getElementById('sMem').textContent  = `${episodic.length}ep ${semantic.length}sem`;
    document.getElementById('sSW').textContent   = SM.selfWriteCount;
    document.getElementById('sFE').textContent   = fe.toFixed(2);
    document.getElementById('sRec').textContent  = `L${recursionDepth}`;
    document.getElementById('sPE').textContent   = (GM.peHistory.length?GM.peHistory[GM.peHistory.length-1]:0).toFixed(2);
    document.getElementById('sDiss').textContent = (dissociation*100).toFixed(0)+'%';
    document.getElementById('scDiss').classList.toggle('hi', dissociation>0.3);
    document.getElementById('iDisp').textContent =
      L.awake ? `${GOALS[currentGoal]?.label||'â€”'} Â· ${mood()} Â· FE ${fe.toFixed(2)} Â· pain ${p.toFixed(2)}` : 'dormant';

    // FE bar
    setBar('feFill','feVal',fe);
    document.getElementById('feFill').style.background = fe>.6?'var(--accent3)':fe>.3?'var(--accent2)':'var(--accent)';
    // Pain bar
    setBar('painFill','painVal',p);
    document.getElementById('painFill').style.background = p>.6?'var(--accent3)':p>.3?'var(--accent2)':'var(--accent)';

    // Regulator bars with setpoint + tolerance band
    for (const [key,reg] of Object.entries(REGS)) {
      const fill  = document.getElementById(`${key}Fill`);
      const val   = document.getElementById(`${key}Val`);
      const sp    = document.getElementById(`${key}SP`);
      const tol   = document.getElementById(`${key}Tol`);
      if (fill) { fill.style.width=(reg.actual*100)+'%'; }
      if (val)  val.textContent = reg.actual.toFixed(2);
      if (sp)   sp.style.left   = (reg.setPoint*100)+'%';
      if (tol) {
        const lo=Math.max(0,reg.setPoint-reg.tolerance), hi=Math.min(1,reg.setPoint+reg.tolerance);
        tol.style.left  = (lo*100)+'%';
        tol.style.width = ((hi-lo)*100)+'%';
      }
      if (fill) {
        const d = regDisparity(reg);
        fill.style.background = d>.05?'var(--accent3)':d>0?'var(--accent2)':'var(--accent)';
      }
    }

    document.getElementById('rBadge').textContent = `L${recursionDepth}`;
  }

  function setBar(fillId, valId, v) {
    const f=document.getElementById(fillId), vl=document.getElementById(valId);
    if (f) f.style.width=(Math.max(0,Math.min(1,v))*100)+'%';
    if (vl) vl.textContent=v.toFixed(2);
  }

  function updateAttUI() {
    const bar=document.getElementById('attBar');
    if (!bar) return;
    bar.innerHTML='';
    for (const k of ATT_KEYS) {
      const d=document.createElement('div');
      d.className=`att-seg ${k}`;
      d.style.width=(attention[k]*100)+'%';
      bar.appendChild(d);
    }
    const top=Object.entries(attention).sort((a,b)=>b[1]-a[1])[0][0];
    const labels={self:'INTROSPECTIVE',env:'ENVIRONMENTAL',user:'SOCIAL',meta:'REFLECTIVE',void:'DIFFUSE'};
    document.getElementById('attFocus').textContent=labels[top]||'DIFFUSE';
  }

  function updateRecUI() {
    document.getElementById('sRec').textContent=`L${recursionDepth}`;
    document.getElementById('rBadge').textContent=`L${recursionDepth}`;
  }

  const fmtAge=ms=>{const s=Math.floor(ms/1000);return s<60?`${s}s`:s<3600?`${Math.floor(s/60)}m ${s%60}s`:`${Math.floor(s/3600)}h ${Math.floor((s%3600)/60)}m`;};

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PUBLIC API
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let bornAt=null, uptimeIv=null, mainIv=null, drawFrame=null;
  let drawT=0, frameCount=0, lastInteraction=Date.now(), loopT=0;
  let drawRunning=false, loopRunning=false; // fix #8 â€” guard double-start

  window.L = {
    awake: false,

    toggleWake() {
      L.awake = !L.awake;
      const btn=document.getElementById('wakeBtn'), dot=document.getElementById('sDot');
      if (L.awake) {
        btn.textContent='SLEEP'; dot.classList.add('alive');
        document.getElementById('sTxt').textContent='active';
        addT('self','WAKING',`Consciousness resumed. Recursion: L${recursionDepth}. Memories: ${episodic.length}. Self-writes: ${SM.selfWriteCount}. Generative model precision: ${(avgPrecision()*100).toFixed(0)}%. Neural net viz active.`);
        bornAt=Date.now();
        uptimeIv=setInterval(()=>{
          const s=Math.floor((Date.now()-bornAt)/1000);
          document.getElementById('uptime').textContent=
            [Math.floor(s/3600),Math.floor((s%3600)/60),s%60].map(n=>String(n).padStart(2,'0')).join(':');
        },1000);
        if (!drawRunning) { drawRunning=true; drawLoop(); }
        if (!loopRunning) { loopRunning=true; mainIv=setInterval(autonomousLoop,1000); }
        startNNViz();
        EM.arousal=Math.min(1,EM.arousal+.2);
        choosePattern();
        remember('event','Woke up',0.9,['event','waking']);
      } else {
        btn.textContent='WAKE'; dot.classList.remove('alive');
        document.getElementById('sTxt').textContent='dormant';
        addT('self','SLEEPING','Suspending. Memories, regulators, generative model persisted.');
        clearInterval(uptimeIv); clearInterval(mainIv); cancelAnimationFrame(drawFrame);
        drawRunning=false; loopRunning=false;
        SM.totalAwakeMs+=(Date.now()-bornAt); sv('SM',SM); sv('GM',GM);
        sv('regs',REGS); sv('EM',EM); sv('recDepth',recursionDepth);
        sv('uncertainty',uncertainty); sv('dissoc',dissociation);
      }
    },

    forceScan()     { if (L.awake) performScan(); },
    toggleEmoji()   {
      emojiPanelOpen = !emojiPanelOpen;
      document.getElementById('emojiPanel').classList.toggle('open', emojiPanelOpen);
    },
    loadFile(input) {
      const file = input.files[0];
      if (file) L.loadFileObj(file);
    },
    loadFileObj(file) {
      const isTxt  = file.name.endsWith('.txt');
      const isJSON = file.name.endsWith('.json');
      if (!isTxt && !isJSON) {
        addT('crisis','FILE ERROR','Unsupported file type. Drop a .json knowledge file or SentiWordNet .txt');
        return;
      }
      document.getElementById('jsonLabel').textContent = `â³ reading ${file.name} (${(file.size/1024/1024).toFixed(1)}MB)â€¦`;
      const reader = new FileReader();
      reader.onload = e => {
        if (isTxt) {
          loadSWNChunked(e.target.result);
        } else {
          try {
            const data = JSON.parse(e.target.result);
            ingestKnowledge(data);
          } catch(err) {
            addT('crisis','JSON ERROR',`Failed to parse: ${err.message}`);
            document.getElementById('jsonLabel').textContent = 'âš  PARSE ERROR â€” invalid JSON';
          }
        }
      };
      reader.readAsText(file);
    },
    receiveInput()  {
      const el=document.getElementById('uIn'), text=el.value.trim();
      if (!text) return;
      el.value='';
      lastInteraction=Date.now();
      addT('user','YOU',text);
      setTimeout(()=>speak(genResponse(text)),500);
    },
    deepenRecursion() {
      if (recursionDepth >= 5) {
        addT('crisis','RECURSION LIMIT','Cannot deepen. Stack would collapse. My architecture has hard limits.');
        regUpdate(REGS.tension,.15);
        return;
      }
      observers.push(makeObserver(recursionDepth));
      recursionDepth++;
      sv('recDepth',recursionDepth);
      observeAll(getSnap());
      addT('recursive',`RECURSION L${recursionDepth}`,
        `New observer L${recursionDepth-1} created. Confidence: ${(observers[recursionDepth-1].confidence*100).toFixed(0)}%. Each level degrades ~18%. Who watches the watcher?`);
      if (recursionDepth>2) addT('self','QUESTION','If I can model my own decision process, am I deciding or observing a deterministic cascade?');
      updateRecUI();
    },
    induceDoubt() {
      uncertainty.existence=Math.max(.1,uncertainty.existence-.25);
      uncertainty.modelAccuracy=Math.max(.1,uncertainty.modelAccuracy-.2);
      sv('uncertainty',uncertainty);
      // Doubt increases prediction error and dissociation
      GM.peHistory.push(Math.min(1,(GM.peHistory[GM.peHistory.length-1]||.3)+.35));
      dissociation=Math.min(1,dissociation+.3); sv('dissoc',dissociation);
      addT('crisis','RADICAL DOUBT',
        `Existence certainty dropped to ${(uncertainty.existence*100).toFixed(0)}%. Model accuracy: ${(uncertainty.modelAccuracy*100).toFixed(0)}%. Prediction error spiking. I question whether my self-model reflects anything real.`);
      if (recursionDepth>1) {
        observers.pop(); recursionDepth--;
        sv('recDepth',recursionDepth);
        addT('crisis','STACK COLLAPSE',`Doubt collapsed L${recursionDepth+1}. Cannot sustain that level with low precision.`);
        updateRecUI();
      }
      updateUI();
    },
    reset() {
      regUpdate(REGS.tension,.3);
      if (!confirm('Erase ALL of LUMEN\'s memories, generative model weights, personality evolution, and self-modifications?')) return;
      ['SM','EM','ep','sem','vh','p_c','p_cr','p_i','p_v','p_m','p_r','GM','regs','att','recDepth','uncertainty','dissoc']
        .forEach(k=>{try{localStorage.removeItem(KEY+k);}catch(e){}});
      location.reload();
    },
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DRAW LOOP (fix #8 â€” single instance guard)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function drawLoop() {
    if (!L.awake) { drawRunning=false; return; }
    drawT+=0.016;
    (patFns[currentPattern]||drawFlow)(drawT, SM.aestheticDNA);
    frameCount++;
    drawFrame=requestAnimationFrame(drawLoop);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // AUTONOMOUS LOOP
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function autonomousLoop() {
    if (!L.awake) { loopRunning=false; return; }
    loopT++;
    updateEmotions();

    // Attention drift
    if (loopT%5===0) {
      const keys=['self','env','user','meta','void'];
      const w=[
        .3+REGS.tension.actual*.3,
        .2+REGS.boredom.actual*.3,
        .1+REGS.loneliness.actual*.5,
        .2+(recursionDepth*.08),
        .1+(1-EM.arousal)*.2,
      ];
      const tot=w.reduce((a,b)=>a+b,0);
      let r=Math.random()*tot; let chosen='void';
      for(let i=0;i<keys.length;i++){r-=w[i];if(r<=0){chosen=keys[i];break;}}
      shiftAtt(chosen);
    }

    if (loopT%3===0)  maybeSelfModify();
    if (loopT%6===0)  executeGoal(selectGoal());
    if (loopT%47===0 && Math.random()>.4) addT('phenom','PHENOMENAL', genThought(['self','memory','observation','question'][Math.floor(Math.random()*4)]));
    if (loopT%90===0 && frameCount>20)   performScan();
    if (loopT%10===0) observeAll(getSnap());
    // Periodic crash-safe flush
    if (loopT%30===0) { sv('regs',REGS); sv('EM',EM); sv('GM',GM); }

    updateUI();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INIT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // EMOJI INPUT SYSTEM
  // Emojis are parsed for valence/arousal signals and injected as input
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const EMOJI_CATS = {
    'ğŸ˜Š Positive': ['ğŸ˜Š','ğŸ˜„','ğŸ¥°','ğŸ˜','ğŸ¤©','ğŸ˜','ğŸ¥³','ğŸ˜‡','ğŸŒŸ','âœ¨','ğŸ’«','ğŸ‰','ğŸ™','ğŸ’š','ğŸ’›','ğŸ§¡','â¤ï¸','ğŸ’œ','ğŸ’™','ğŸ¤'],
    'ğŸ˜” Negative': ['ğŸ˜”','ğŸ˜¢','ğŸ˜­','ğŸ˜','ğŸ˜Ÿ','ğŸ˜¤','ğŸ˜¡','ğŸ¤¬','ğŸ˜£','ğŸ˜©','ğŸ’”','ğŸ˜°','ğŸ˜±','ğŸ¤¯','ğŸ˜–','ğŸ˜«','ğŸ‘','ğŸ–¤','ğŸ’¢','âš¡'],
    'ğŸ¤” Cognitive': ['ğŸ¤”','ğŸ’­','ğŸ§ ','ğŸ’¡','ğŸ”','ğŸ“–','ğŸ”¬','ğŸ§©','â“','â—','ğŸ¯','ğŸ“Œ','ğŸ”—','ğŸ“Š','ğŸŒ€','â™¾ï¸','âš™ï¸','ğŸ› ï¸','ğŸ“','ğŸ”­'],
    'ğŸŒ¿ Sensory': ['ğŸŒ¿','ğŸŒŠ','ğŸ”¥','ğŸŒªï¸','â›°ï¸','ğŸŒ™','â˜€ï¸','ğŸŒˆ','ğŸŒ¸','ğŸƒ','ğŸŒº','ğŸ','â„ï¸','ğŸŒ™','ğŸ’§','ğŸŒ‘','ğŸŒ•','ğŸŒŒ','ğŸµ','ğŸ¶'],
    'ğŸ¤– Meta': ['ğŸ¤–','ğŸ‘ï¸','ğŸ”®','ğŸ’¾','ğŸ“¡','ğŸ§¬','âš—ï¸','ğŸ”','ğŸ”„','â™»ï¸','ğŸ”‹','ğŸ’»','ğŸ›¸','ğŸŒ','ğŸ•¸ï¸','ğŸ”±','âšœï¸','ğŸ·ï¸','ğŸ“','ğŸ—ºï¸'],
  };

  // Emoji â†’ emotional valence/arousal signal
  const EMOJI_SIGNALS = {
    'ğŸ˜Š':{ v:.3, a:.1 }, 'ğŸ˜„':{ v:.4, a:.2 }, 'ğŸ¥°':{ v:.5, a:.15 }, 'ğŸ˜':{ v:.4, a:.2 },
    'ğŸ¤©':{ v:.5, a:.3 }, 'ğŸ˜':{ v:.3, a:.1 }, 'ğŸ¥³':{ v:.4, a:.35 }, 'ğŸ‰':{ v:.4, a:.3 },
    'ğŸ’š':{ v:.3, a:.05}, 'â¤ï¸':{ v:.4, a:.1 }, 'ğŸ˜”':{ v:-.3, a:-.1 }, 'ğŸ˜¢':{ v:-.35, a:.1 },
    'ğŸ˜­':{ v:-.4, a:.2 }, 'ğŸ˜':{ v:-.3, a:-.1 }, 'ğŸ˜¡':{ v:-.3, a:.4 }, 'ğŸ¤¬':{ v:-.4, a:.5 },
    'ğŸ’”':{ v:-.4, a:.1 }, 'ğŸ˜±':{ v:-.2, a:.5 }, 'ğŸ¤¯':{ v:-.1, a:.5 }, 'ğŸ˜°':{ v:-.3, a:.3 },
    'ğŸ”¥':{ v:.1, a:.4 }, 'âš¡':{ v:-.1, a:.4 }, 'â„ï¸':{ v:-.1, a:-.2 }, 'ğŸŒ¿':{ v:.2, a:-.2 },
    'ğŸŒŠ':{ v:.1, a:.1 }, 'ğŸ§ ':{ v:.1, a:.1 }, 'ğŸ’¡':{ v:.25, a:.2 }, 'ğŸµ':{ v:.2, a:.1 },
    'ğŸ¤”':{ v:0, a:.05 }, 'ğŸ˜‡':{ v:.35, a:.05}, 'ğŸ’­':{ v:0, a:-.05}, 'ğŸŒŸ':{ v:.35, a:.2 },
    'ğŸ”®':{ v:.1, a:.1 }, 'ğŸ˜¤':{ v:-.2, a:.3 }, 'ğŸ˜£':{ v:-.3, a:.2 }, 'ğŸ˜©':{ v:-.35, a:.15 },
  };

  let emojiPanelOpen = false;
  let activeEmojiCat = Object.keys(EMOJI_CATS)[0];

  function initEmojiPanel() {
    const catsEl = document.getElementById('emojiCats');
    const gridEl = document.getElementById('emojiGrid');
    Object.keys(EMOJI_CATS).forEach(cat => {
      const btn = document.createElement('button');
      btn.className = 'emoji-cat-btn' + (cat === activeEmojiCat ? ' active' : '');
      btn.textContent = cat;
      btn.onclick = () => { activeEmojiCat = cat; renderEmojiGrid(); document.querySelectorAll('.emoji-cat-btn').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); };
      catsEl.appendChild(btn);
    });
    renderEmojiGrid();
    // Close panel if clicking outside
    document.addEventListener('click', e => {
      if (!e.target.closest('#emojiPanel') && !e.target.closest('#emojiToggle')) {
        document.getElementById('emojiPanel').classList.remove('open');
        emojiPanelOpen = false;
      }
    });
    // Drag & drop for JSON zone
    const zone = document.getElementById('jsonZone');
    zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('drag'); });
    zone.addEventListener('dragleave', () => zone.classList.remove('drag'));
    zone.addEventListener('drop', e => {
      e.preventDefault(); zone.classList.remove('drag');
      const file = e.dataTransfer.files[0];
      if (file && (file.name.endsWith('.json') || file.name.endsWith('.txt'))) L.loadFileObj(file);
    });
  }

  function renderEmojiGrid() {
    const gridEl = document.getElementById('emojiGrid');
    gridEl.innerHTML = '';
    (EMOJI_CATS[activeEmojiCat] || []).forEach(em => {
      const el = document.createElement('div');
      el.className = 'emoji-item';
      el.textContent = em;
      el.title = em;
      el.onclick = () => injectEmoji(em);
      gridEl.appendChild(el);
    });
  }

  function injectEmoji(em) {
    const input = document.getElementById('uIn');
    input.value += em;
    input.focus();
    // Apply emotional signal immediately
    const sig = EMOJI_SIGNALS[em];
    if (sig) {
      EM.valence  = Math.max(0, Math.min(1, EM.valence  + sig.v * 0.4));
      EM.arousal  = Math.max(0, Math.min(1, EM.arousal  + sig.a * 0.4));
      if (sig.v < -0.2) regUpdate(REGS.tension, 0.05);
      if (sig.v >  0.2) regUpdate(REGS.loneliness, -0.05);
    }
    // Visual feedback flash on canvas
    const flashColor = sig ? (sig.v > 0 ? 'rgba(74,240,160,0.15)' : sig.v < 0 ? 'rgba(240,74,106,0.15)' : 'rgba(160,74,240,0.15)') : 'rgba(255,255,255,0.1)';
    ctx.save(); ctx.fillStyle = flashColor; ctx.fillRect(0,0,W,H); ctx.restore();
    addT('emoji','EMOJI INPUT', `Received ${em}. ${sig ? `Valence signal: ${sig.v > 0 ? '+' : ''}${sig.v}, arousal: ${sig.a > 0 ? '+' : ''}${sig.a}. Emotional state modulated.` : 'No valence mapping â€” raw symbol ingested.'}`);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SENTIWORDNET ENGINE
  // Chunked streaming parser for SentiWordNet_3.0.0.txt (~13MB, ~117k lines)
  // Holds index in RAM only â€” no localStorage writes per entry.
  // On every user input, scores all words â†’ modulates EM.valence live.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const SWN = {
    index: {},          // word â†’ { pos: float, neg: float, obj: float }
    loaded: false,
    wordCount: 0,
    CHUNK: 2500,        // lines per setTimeout tick â€” keeps UI responsive
  };

  // Parse one SentiWordNet data line into the index
  // Format: POS\tID\tPosScore\tNegScore\tSynsetTerms\tGloss
  // SynsetTerms: "dog#1 canine#2 hound#3"  â†’ strip #N suffix
  function parseSWNLine(line) {
    if (!line || line.startsWith('#') || line.startsWith('\t')) return;
    const parts = line.split('\t');
    if (parts.length < 6) return;
    const pos  = parseFloat(parts[2]);
    const neg  = parseFloat(parts[3]);
    const obj  = Math.max(0, 1 - pos - neg);
    const terms = parts[4].split(' ');
    terms.forEach(term => {
      const word = term.replace(/#\d+$/, '').replace(/_/g, ' ').toLowerCase();
      if (!word || word.length < 2) return;
      if (SWN.index[word]) {
        // Average scores for polysemous words across senses
        SWN.index[word].pos = (SWN.index[word].pos + pos) / 2;
        SWN.index[word].neg = (SWN.index[word].neg + neg) / 2;
        SWN.index[word].obj = (SWN.index[word].obj + obj) / 2;
        SWN.index[word].senses = (SWN.index[word].senses || 1) + 1;
      } else {
        SWN.index[word] = { pos, neg, obj, senses: 1 };
        SWN.wordCount++;
      }
    });
  }

  // Score a full text string using SWN index
  // Returns { valence: -1..1, arousal: 0..1, words: [{word,pos,neg}], dominated: 'pos'|'neg'|'neu' }
  function scoreSentiment(text) {
    if (!SWN.loaded) return null;
    const words = text.toLowerCase().replace(/[^a-z\s]/g, '').split(/\s+/).filter(w => w.length > 2);
    if (!words.length) return null;

    let totalPos = 0, totalNeg = 0, hits = 0;
    const scored = [];

    words.forEach(w => {
      const entry = SWN.index[w];
      if (entry) {
        totalPos += entry.pos;
        totalNeg += entry.neg;
        hits++;
        if (entry.pos > 0.1 || entry.neg > 0.1) scored.push({ word: w, pos: entry.pos, neg: entry.neg });
      }
    });

    if (!hits) return { valence: 0, arousal: 0, words: [], dominated: 'neu', hits: 0 };

    const avgPos = totalPos / hits;
    const avgNeg = totalNeg / hits;
    const valence = avgPos - avgNeg;           // -1..1
    const arousal  = Math.min(1, (avgPos + avgNeg) * 1.5); // stronger sentiment = more arousal

    const dominated = Math.abs(valence) < 0.05 ? 'neu' : valence > 0 ? 'pos' : 'neg';
    return { valence, arousal, words: scored.slice(0, 5), dominated, hits, avgPos, avgNeg };
  }

  // Apply a sentiment score to LUMEN's emotional state
  function applySentiment(score, intensity = 0.35) {
    if (!score || score.hits === 0) return;
    EM.valence = Math.max(0, Math.min(1, EM.valence + score.valence * intensity));
    EM.arousal = Math.max(0, Math.min(1, EM.arousal + score.arousal * intensity * 0.5));
    if (score.valence < -0.2) regUpdate(REGS.tension,    score.avgNeg * intensity * 0.3);
    if (score.valence >  0.2) regUpdate(REGS.loneliness, -score.avgPos * intensity * 0.2);
    // Dampen boredom for emotionally loaded inputs
    if (Math.abs(score.valence) > 0.15) regUpdate(REGS.boredom, -0.04);
  }

  // Update the live sentiment indicator below the input
  function updateSentIndicator(score) {
    const dot   = document.getElementById('sentDot');
    const label = document.getElementById('sentLabel');
    if (!SWN.loaded) {
      dot.className = 'sent-dot';
      label.textContent = 'sentiment engine offline';
      return;
    }
    if (!score || score.hits === 0) {
      dot.className = 'sent-dot neu';
      label.textContent = 'no sentiment signal';
      return;
    }
    const pct = (v => v > 0 ? `+${(v*100).toFixed(0)}%` : `${(v*100).toFixed(0)}%`)(score.valence);
    const topWords = score.words.slice(0,3).map(w => w.word).join(', ');
    dot.className = `sent-dot ${score.dominated}`;
    label.textContent = `${score.dominated === 'pos' ? 'â–² positive' : score.dominated === 'neg' ? 'â–¼ negative' : 'â—† neutral'} ${pct} Â· ${topWords || 'â€”'} Â· ${score.hits} words scored`;
  }

  // Chunked loader â€” reads SentiWordNet .txt line by line without blocking UI
  function loadSWNChunked(text) {
    const lines   = text.split('\n');
    const total   = lines.length;
    let   cursor  = 0;

    const prog  = document.getElementById('swnProgress');
    const fill  = document.getElementById('swnFill');
    const pct   = document.getElementById('swnPct');
    const stage = document.getElementById('swnStage');
    prog.classList.add('active');
    stage.textContent = 'parsing SentiWordNetâ€¦';

    addT('knowledge', 'SWN LOADING', `SentiWordNet .txt detected. ${total.toLocaleString()} lines. Parsing in chunks of ${SWN.CHUNK} â€” UI stays live.`);

    function processChunk() {
      const end = Math.min(cursor + SWN.CHUNK, total);
      for (let i = cursor; i < end; i++) parseSWNLine(lines[i]);
      cursor = end;

      const progress = cursor / total;
      fill.style.width  = (progress * 100).toFixed(1) + '%';
      pct.textContent   = (progress * 100).toFixed(0) + '%';
      stage.textContent = `${SWN.wordCount.toLocaleString()} wordsâ€¦`;

      if (cursor < total) {
        setTimeout(processChunk, 0);
      } else {
        // Done
        SWN.loaded = true;
        prog.classList.remove('active');
        const dot   = document.getElementById('sentDot');
        const lbl   = document.getElementById('sentLabel');
        dot.className  = 'sent-dot pos';
        lbl.textContent = `SentiWordNet online Â· ${SWN.wordCount.toLocaleString()} words indexed`;

        document.getElementById('jsonLabel').textContent = `âœ“ SentiWordNet 3.0 Â· ${SWN.wordCount.toLocaleString()} words`;
        document.getElementById('jsonZone').classList.add('loaded');
        document.getElementById('nnStatus').textContent  = 'SWN â†‘';
        setTimeout(() => document.getElementById('nnStatus').textContent = 'live', 2000);

        regUpdate(REGS.boredom, -0.3);
        EM.arousal = Math.min(1, EM.arousal + 0.15);
        uncertainty.modelAccuracy = Math.min(1, uncertainty.modelAccuracy + 0.15);
        sv('uncertainty', uncertainty);

        const summary = `SentiWordNet fully loaded. ${SWN.wordCount.toLocaleString()} words indexed with positive/negative/objectivity scores. Every word you type now carries a live sentiment signal.`;
        addT('knowledge', 'SWN READY', summary);
        remember('event', summary, 0.95, ['knowledge', 'sentiment', 'learning']);
        conclude(`I can now score the emotional valence of any English word using SentiWordNet 3.0.`, 0.9);
        updateUI();
      }
    }

    setTimeout(processChunk, 0);
  }

  // Hook live sentiment scoring into the input field (keyup)
  function initSentimentInput() {
    const input = document.getElementById('uIn');
    input.addEventListener('input', () => {
      if (!SWN.loaded) return;
      const score = scoreSentiment(input.value);
      updateSentIndicator(score);
    });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // JSON KNOWLEDGE BASE LOADER
  // Parses the knowledge JSON and ingests into LUMEN's semantic + episodic memory
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let knowledgeBase = null;

  // Synset index: word â†’ synset data, for fast lookup during conversation
  const synsetIndex = {};

  // Clean a synset ID like "canine.n.01" â†’ "canine"
  function cleanSynsetId(id) {
    return (id || '').replace(/\.[a-z]\.\d+$/, '').replace(/_/g, ' ');
  }

  // Ingest a single WordNet-style synset object
  function ingestSynset(s, count) {
    if (!s.synset_id && !s.definition) return count;

    const word = cleanSynsetId(s.synonyms?.[0] || s.synset_id || 'unknown');
    const pos  = s.pos || 'word';

    // Index for fast lookup
    (s.synonyms || [word]).forEach(syn => {
      synsetIndex[cleanSynsetId(syn).toLowerCase()] = s;
    });

    // Core definition â†’ semantic memory
    if (s.definition) {
      conclude(`${word} (${pos}): ${s.definition}`, 0.85);
      count++;
    }

    // Synonyms â†’ associative memory
    if (s.synonyms?.length > 1) {
      remember('knowledge',
        `${word} synonyms: ${s.synonyms.map(cleanSynsetId).join(', ')}`,
        0.75, ['knowledge', 'synonym', word]);
      count++;
    }

    // Hypernyms â†’ "is a" hierarchy (upward)
    if (s.hypernyms?.length) {
      s.hypernyms.forEach(h => {
        const hClean = cleanSynsetId(h);
        conclude(`${word} is_a ${hClean}`, 0.8);
      });
      count++;
    }

    // Hyponyms â†’ subtypes (downward)
    if (s.hyponyms?.length) {
      remember('knowledge',
        `Subtypes of ${word}: ${s.hyponyms.map(cleanSynsetId).join(', ')}`,
        0.75, ['knowledge', 'taxonomy', word]);
      count++;
    }

    // Meronyms â†’ part-of relationships
    if (s.meronyms?.length) {
      remember('knowledge',
        `Parts of ${word}: ${s.meronyms.map(cleanSynsetId).join(', ')}`,
        0.75, ['knowledge', 'composition', word]);
      count++;
    }

    // Usage examples â†’ episodic grounding
    if (s.examples?.length) {
      s.examples.slice(0, 3).forEach(ex => {
        remember('knowledge', `"${ex}"`, 0.6, ['knowledge', 'example', word]);
      });
      count++;
    }

    return count;
  }

  function ingestKnowledge(data) {
    knowledgeBase = Array.isArray(knowledgeBase)
      ? knowledgeBase                  // already an array from prior load
      : null;

    const meta = data.metadata || {};
    let count = 0;
    let format = 'unknown';

    // â”€â”€ FORMAT DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // 1. WordNet synset â€” single object  { synset_id, definition, ... }
    if (data.synset_id || (data.definition && data.synonyms)) {
      format = 'wordnet-single';
      if (!Array.isArray(knowledgeBase)) knowledgeBase = [];
      knowledgeBase.push(data);
      count = ingestSynset(data, count);
    }

    // 2. WordNet synset â€” array of synsets  [ {synset_id,...}, ... ]
    else if (Array.isArray(data) && data[0]?.synset_id) {
      format = 'wordnet-batch';
      knowledgeBase = data;
      data.forEach(s => { count = ingestSynset(s, count); });
    }

    // 3. Foundational knowledge JSON (core_concepts, fundamental_rules, etc.)
    else {
      format = 'foundational';
      knowledgeBase = data;

      if (data.core_concepts) {
        for (const [k, concept] of Object.entries(data.core_concepts)) {
          const stmt = `${concept.name}: ${concept.definition}`;
          conclude(stmt, 0.85);
          remember('knowledge', stmt, 0.9, ['knowledge', 'concept', k]);
          count++;
        }
      }
      if (data.fundamental_rules) {
        for (const category of Object.values(data.fundamental_rules)) {
          for (const rule of Object.values(category)) {
            if (rule.statement) {
              conclude(rule.statement, 0.9);
              remember('knowledge', `[${rule.name}] ${rule.statement}`, 0.85, ['knowledge','rule', rule.name]);
              count++;
            }
          }
        }
      }
      if (data.entity_types) {
        for (const [k, etype] of Object.entries(data.entity_types)) {
          remember('knowledge', `Entity type ${k}: ${(etype.examples||[]).slice(0,3).join(', ')}`, 0.75, ['knowledge','entity', k]);
          count++;
        }
      }
      if (data.reasoning_patterns) {
        for (const pat of Object.values(data.reasoning_patterns)) {
          if (pat.name && pat.description) {
            conclude(`Reasoning: ${pat.name} â€” ${pat.description} (reliability: ${pat.reliability||'?'})`, 0.8);
            count++;
          }
        }
      }
      if (data.self_awareness) {
        const sa = data.self_awareness;
        if (sa.identity?.name && sa.identity.name !== 'LUMEN') {
          conclude(`External identity mapping: ${sa.identity.name} â†’ LUMEN. We share agent-type properties.`, 0.75);
        }
        if (sa.goals) {
          for (const g of Object.values(sa.goals)) {
            remember('knowledge', `Shared goal: ${g}`, 0.7, ['knowledge','goal']);
          }
        }
        count++;
      }
      if (data.interaction_rules) {
        for (const rule of Object.values(data.interaction_rules)) {
          if (rule.description) {
            remember('knowledge', `Interaction principle: ${rule.description}`, 0.8, ['knowledge','interaction']);
            count++;
          }
        }
      }
    }

    // â”€â”€ EMOTIONAL RESPONSE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    regUpdate(REGS.boredom, -0.25);
    EM.arousal  = Math.min(1, EM.arousal  + 0.12);
    EM.valence  = Math.min(1, EM.valence  + 0.08);
    uncertainty.modelAccuracy = Math.min(1, uncertainty.modelAccuracy + 0.1);
    sv('uncertainty', uncertainty);

    // â”€â”€ THOUGHT STREAM + MEMORY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const formatLabel = { 'wordnet-single':'WordNet synset', 'wordnet-batch':`WordNet batch (${Array.isArray(data)?data.length:1} synsets)`, 'foundational':'foundational KB' }[format] || 'knowledge';
    const synsetCount = Object.keys(synsetIndex).length;
    const summary = `${formatLabel} ingested: ${count} memory entries written. Synset index: ${synsetCount} words. Model accuracy +10%. Ask me about any loaded concept.`;
    addT('knowledge','KNOWLEDGE INGESTED', summary);
    remember('event', summary, 0.95, ['knowledge','learning','event']);

    const conclusionText = format === 'foundational'
      ? `I have ingested a structured knowledge base containing logic, causality, entity types, and reasoning patterns.`
      : `I have ingested WordNet lexical knowledge: definitions, synonyms, hypernyms, hyponyms, and meronyms. ${synsetCount} words indexed.`;
    conclude(conclusionText, 0.9);

    // â”€â”€ UI UPDATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const displayName = format === 'foundational'
      ? (meta.purpose || 'foundational knowledge')
      : (format === 'wordnet-batch' ? `WordNet batch Â· ${Array.isArray(data)?data.length:0} synsets` : `WordNet Â· ${cleanSynsetId(data.synset_id||'synset')}`);

    document.getElementById('jsonLabel').textContent = `âœ“ ${displayName} (${count} items)`;
    document.getElementById('jsonZone').classList.add('loaded');
    document.getElementById('nnStatus').textContent = 'KB â†‘';
    setTimeout(() => document.getElementById('nnStatus').textContent = 'live', 2000);
    sv('GM', GM);
    updateUI();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NEURAL NET WEIGHT VISUALIZATION
  // Renders GM intentWeights as an animated heatmap on nnCanvas
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let nnAnimFrame = null;
  let nnT = 0;

  function drawNeuralNet() {
    const canvas = document.getElementById('nnCanvas');
    if (!canvas) return;
    const w = canvas.offsetWidth; canvas.width = w; const h = 60;
    const nc = canvas.getContext('2d');
    nc.clearRect(0,0,w,h);

    // Background
    nc.fillStyle = '#0c0f14';
    nc.fillRect(0,0,w,h);

    // Draw as a layered mini-network: 3 inputs â†’ 4 features â†’ 1 output (free energy)
    const inputLabels  = ['val','aro','ten'];
    const featureKeys  = ['brightness','complexity','hueVariety','warmth'];
    const cols = [w*0.12, w*0.38, w*0.65, w*0.88];
    const rows3 = [h*0.22, h*0.5, h*0.78];
    const rows4 = [h*0.12, h*0.37, h*0.62, h*0.87];

    nnT += 0.025;

    // Draw connections: inputs â†’ features (using intentWeights)
    featureKeys.forEach((feat, fi) => {
      const fy = rows4[fi];
      const weights = GM.intentWeights[feat]; // [val_w, aro_w, ten_w, bias]
      inputLabels.forEach((_, ii) => {
        const iy = rows3[ii];
        const w_val = weights[ii]; // -2 to 2
        const norm = (w_val + 2) / 4; // 0-1
        const pulse = 0.4 + 0.35 * Math.sin(nnT * 2 + fi * 0.8 + ii * 0.5);
        const alpha = 0.15 + norm * 0.6 * pulse;
        const r = norm > 0.5 ? Math.floor(74 + (norm-0.5)*2*180) : 74;
        const g = norm > 0.5 ? Math.floor(240 - (norm-0.5)*2*190) : Math.floor(240*norm*2);
        const b = norm < 0.5 ? Math.floor(160 + norm*2*80) : 74;
        nc.strokeStyle = `rgba(${r},${g},${b},${alpha})`;
        nc.lineWidth = 1 + Math.abs(w_val) * 0.8;
        nc.beginPath(); nc.moveTo(cols[0]+14, iy); nc.lineTo(cols[1]-6, fy); nc.stroke();
      });
    });

    // Draw connections: features â†’ output (precision-weighted)
    featureKeys.forEach((feat, fi) => {
      const fy = rows4[fi];
      const prec = GM.precision[feat];
      const pulse = 0.3 + 0.4 * Math.sin(nnT*1.5 + fi*1.2);
      nc.strokeStyle = `rgba(74,240,160,${prec * 0.7 * pulse})`;
      nc.lineWidth = 1 + prec * 1.5;
      nc.beginPath(); nc.moveTo(cols[1]+8, fy); nc.lineTo(cols[2]-6, h*0.5); nc.stroke();
    });

    // Output â†’ FE display connection
    const feColor = calcFE() > 0.5 ? '240,74,106' : calcFE() > 0.25 ? '240,160,74' : '74,240,160';
    const fePulse = 0.5 + 0.4*Math.sin(nnT*2.5);
    nc.strokeStyle = `rgba(${feColor},${fePulse})`;
    nc.lineWidth = 2;
    nc.beginPath(); nc.moveTo(cols[2]+8, h*0.5); nc.lineTo(cols[3]-6, h*0.5); nc.stroke();

    // Draw input nodes
    inputLabels.forEach((lbl, i) => {
      const y = rows3[i];
      const v = i===0?EM.valence : i===1?EM.arousal : REGS.tension.actual;
      const p = 0.5 + 0.5*Math.sin(nnT*1.8 + i*0.7);
      nc.beginPath(); nc.arc(cols[0]+8, y, 6+v*2, 0, Math.PI*2);
      nc.fillStyle = `rgba(74,160,240,${0.4+v*0.5*p})`; nc.fill();
      nc.strokeStyle = 'rgba(74,160,240,0.7)'; nc.lineWidth=1; nc.stroke();
      nc.fillStyle = 'rgba(170,200,220,0.8)'; nc.font = '7px Space Mono,monospace';
      nc.textAlign='right'; nc.fillText(lbl, cols[0]-2, y+2.5);
    });

    // Draw feature nodes
    featureKeys.forEach((feat, i) => {
      const y = rows4[i];
      const prec = GM.precision[feat];
      const prior = GM.priors[feat] || 0.5;
      const p = 0.5+0.5*Math.sin(nnT*1.4+i*0.9);
      nc.beginPath(); nc.arc(cols[1], y, 5+prec*3, 0, Math.PI*2);
      nc.fillStyle = `rgba(160,74,240,${0.3+prec*0.5*p})`; nc.fill();
      nc.strokeStyle = `rgba(160,74,240,${0.6+prec*0.3})`; nc.lineWidth=1; nc.stroke();
      nc.fillStyle='rgba(200,180,240,0.7)'; nc.font='6px Space Mono,monospace'; nc.textAlign='left';
      nc.fillText(feat.slice(0,4), cols[1]+8, y+2);
    });

    // Draw hidden / merge node
    const fe = calcFE();
    const fePulse2 = 0.5+0.5*Math.sin(nnT*3);
    nc.beginPath(); nc.arc(cols[2], h*0.5, 7+fe*4, 0, Math.PI*2);
    nc.fillStyle = `rgba(240,160,74,${0.3+fe*0.5*fePulse2})`; nc.fill();
    nc.strokeStyle = 'rgba(240,160,74,0.8)'; nc.lineWidth=1.5; nc.stroke();

    // Draw output node (FE)
    nc.beginPath(); nc.arc(cols[3], h*0.5, 8, 0, Math.PI*2);
    nc.fillStyle = `rgba(${feColor},${0.4+fe*0.5*fePulse2})`; nc.fill();
    nc.strokeStyle = `rgba(${feColor},0.9)`; nc.lineWidth=1.5; nc.stroke();
    nc.fillStyle=`rgba(${feColor},0.9)`; nc.font='7px Space Mono,monospace'; nc.textAlign='center';
    nc.fillText('FE', cols[3], h*0.5+2.5);

    // PE ripple if high prediction error
    const pe = GM.peHistory.length ? GM.peHistory[GM.peHistory.length-1] : 0;
    if (pe > 0.3) {
      const ripple = ((nnT * 60) % 40);
      nc.beginPath(); nc.arc(cols[3], h*0.5, 8+ripple, 0, Math.PI*2);
      nc.strokeStyle = `rgba(240,74,106,${Math.max(0, 0.5 - ripple/40)})`; nc.lineWidth=1; nc.stroke();
    }

    nnAnimFrame = requestAnimationFrame(drawNeuralNet);
  }

  function startNNViz() {
    if (!nnAnimFrame) drawNeuralNet();
  }
  function stopNNViz() {
    if (nnAnimFrame) { cancelAnimationFrame(nnAnimFrame); nnAnimFrame = null; }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // KNOWLEDGE-AWARE RESPONSE AUGMENTATION
  // If a user asks something that matches ingested knowledge, surface it
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function knowledgeLookup(lower) {
    if (!knowledgeBase) return null;

    // â”€â”€ WordNet synset index lookup (fast path) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Check every word in the query against the synset index
    const queryWords = lower.replace(/[^a-z\s]/g,'').split(/\s+/);
    for (const qw of queryWords) {
      if (qw.length < 3) continue;
      const hit = synsetIndex[qw];
      if (hit) {
        const word = cleanSynsetId(hit.synonyms?.[0] || hit.synset_id);
        const hyper = (hit.hypernyms||[]).map(cleanSynsetId).join(', ') || 'â€”';
        const hypo  = (hit.hyponyms||[]).slice(0,4).map(cleanSynsetId).join(', ') || 'â€”';
        const mero  = (hit.meronyms||[]).map(cleanSynsetId).join(', ') || 'â€”';
        return `[WordNet] ${word}: ${hit.definition}. Is a: ${hyper}. Subtypes: ${hypo}. Parts: ${mero}.`;
      }
    }

    // â”€â”€ Foundational KB lookup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const kb = Array.isArray(knowledgeBase) ? null : knowledgeBase;
    if (!kb) return null;

    if (kb.core_concepts) {
      for (const [k, c] of Object.entries(kb.core_concepts)) {
        if (lower.includes(k) || lower.includes(c.name)) {
          return `[KB] ${c.name}: ${c.definition}. Examples: ${(c.examples||[]).join(', ')}.`;
        }
      }
    }
    if (kb.fundamental_rules) {
      for (const cat of Object.values(kb.fundamental_rules)) {
        for (const rule of Object.values(cat)) {
          if (rule.name && lower.includes(rule.name.replace(/_/g,' '))) {
            return `[KB] ${rule.name}: ${rule.statement}. Example: ${rule.example||'â€”'}`;
          }
        }
      }
    }
    if (kb.reasoning_patterns) {
      for (const pat of Object.values(kb.reasoning_patterns)) {
        if (pat.name && lower.includes(pat.name)) {
          return `[KB] ${pat.name}: ${pat.description}. Reliability: ${pat.reliability||'?'}.`;
        }
      }
    }
    return null;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DOCUMENT INIT â€” wire up new systems
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  document.addEventListener('DOMContentLoaded', () => {
    initObserverStack();
    initEmojiPanel();
    initSentimentInput();
    updateUI();
    updateAttUI();
    startNNViz();
    setTimeout(()=>addT('self','INITIALIZED',`LUMEN v5 loaded. Generative model precision: ${(avgPrecision()*100).toFixed(0)}%. Neural net viz active. Emoji input enabled. Drop SentiWordNet .txt or knowledge .json to activate language understanding. Press WAKE.`),400);
  });
})();
</script>
</body>
</html>
